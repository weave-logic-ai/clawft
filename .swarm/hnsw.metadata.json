[["entry_1771266857024_z2qe3l",{"id":"entry_1771266857024_z2qe3l","key":"nanobot-architecture","namespace":"nanobot-analysis","content":"Nanobot is a ~9100-line Python AI agent framework. Core modules: agent/loop.py (476 lines, main processing engine), cli/commands.py (935 lines, typer CLI), config/schema.py (304 lines, pydantic config), channels/manager.py (227 lines), providers/litellm_provider.py (208 lines). Architecture: MessageBus (async queues) decouples channels from agent core. Agent loop: receive msg -> build context (system prompt + history + memory + skills) -> call LLM -> execute tool calls in loop -> send response. 9 channels: Telegram, WhatsApp, Discord, Slack, Feishu, DingTalk, QQ, Mochat, Email. 14 providers via LiteLLM + OpenAI Codex OAuth. 8 tool types: filesystem (read/write/edit/listdir), shell (exec), web (search/fetch), message, spawn, cron, MCP. Session management via JSONL files. Memory: MEMORY.md (long-term facts) + HISTORY.md (grep-searchable log). Skills: markdown SKILL.md files with YAML frontmatter. Cron: at/every/cron scheduling. Heartbeat: periodic HEARTBEAT.md check. Subagents: lightweight background agent instances. WhatsApp bridge: separate Node.js/TypeScript process using Baileys, communicates via WebSocket."}],["entry_1771266876113_ir8xpf",{"id":"entry_1771266876113_ir8xpf","key":"nanobot-dependencies","namespace":"nanobot-analysis","content":"Python deps: typer (CLI), litellm (multi-provider LLM), pydantic/pydantic-settings (config), websockets/websocket-client (WS), httpx (HTTP client), loguru (logging), readability-lxml (web content extraction), rich (terminal UI), croniter (cron expressions), prompt-toolkit (interactive input), mcp (MCP protocol client), json-repair (JSON fixing), slackify-markdown (Slack formatting). Channel-specific: python-telegram-bot, slack-sdk, qq-botpy, dingtalk-stream, lark-oapi, python-socketio, msgpack, socksio/python-socks. Bridge: @whiskeysockets/baileys (WhatsApp), ws (WebSocket server), pino (logging). Heavy deps that need Rust equivalents: litellm -> custom HTTP client, pydantic -> serde, httpx -> reqwest, asyncio -> tokio."}],["entry_1771266884068_s2gu2e",{"id":"entry_1771266884068_s2gu2e","key":"nanobot-module-map","namespace":"nanobot-analysis","content":"Module sizes (lines): cli/commands.py:935, channels/mochat.py:895, agent/loop.py:476, channels/email.py:403, channels/feishu.py:402, providers/registry.py:395, channels/telegram.py:390, cron/service.py:351, providers/openai_codex_provider.py:312, config/schema.py:304, channels/discord.py:261, agent/subagent.py:257, channels/dingtalk.py:245, agent/context.py:238, channels/slack.py:235, channels/manager.py:227, agent/skills.py:228, agent/tools/filesystem.py:211, providers/litellm_provider.py:208, session/manager.py:179, agent/tools/web.py:163, channels/whatsapp.py:148, agent/tools/shell.py:144, channels/qq.py:134, heartbeat/service.py:130, channels/base.py:127, agent/tools/cron.py:127, config/loader.py:106, agent/tools/base.py:102, agent/tools/message.py:86, bus/queue.py:81, agent/tools/mcp.py:80, utils/helpers.py:80, agent/tools/registry.py:73, providers/base.py:70, providers/transcription.py:65, agent/tools/spawn.py:65, cron/types.py:59, bus/events.py:37, agent/memory.py:30. Total: ~9134 lines Python + ~350 lines TypeScript bridge."}],["entry_1771266891365_bva75",{"id":"entry_1771266891365_bva75","key":"nanobot-data-flow","namespace":"nanobot-analysis","content":"Data flow: 1) Channels (telegram/slack/etc) receive messages -> create InboundMessage(channel, sender_id, chat_id, content, media, metadata) -> push to MessageBus.inbound queue. 2) AgentLoop.run() consumes from inbound queue -> _process_message() -> looks up/creates Session -> builds context (system prompt + bootstrap files + memory + skills + history + current msg) -> _run_agent_loop() iterates: call provider.chat() -> if tool_calls: execute tools, add results, continue; if content only: break. 3) Response saved to session -> OutboundMessage pushed to outbound queue. 4) ChannelManager._dispatch_outbound() routes messages to correct channel.send(). Key interfaces: Tool(ABC) with name/description/parameters/execute, LLMProvider(ABC) with chat/get_default_model, BaseChannel(ABC) with start/stop/send. Config: ~/.nanobot/config.json (camelCase JSON, converted to snake_case pydantic). Sessions: ~/.nanobot/sessions/*.jsonl. Workspace: ~/.nanobot/workspace/ with AGENTS.md, SOUL.md, USER.md, memory/, skills/."}],["entry_1771266898535_7q6q6y",{"id":"entry_1771266898535_7q6q6y","key":"nanobot-rust-rewrite-plan","namespace":"nanobot-analysis","content":"Rust/WASM Rewrite Plan - Target: lightweight, portable WASM binary for small devices. Core architecture stays the same: message bus + agent loop + channels + tools. Key decisions: 1) Use tokio for async runtime (not in WASM; use wasm-bindgen-futures for WASM target). 2) serde + serde_json for config/serialization. 3) reqwest (with wasm feature) for HTTP. 4) Custom LLM provider trait (no litellm equivalent in Rust). 5) Channel implementations as optional features (compile-time feature flags). 6) Tool system: trait-based with dynamic dispatch. 7) Config: keep JSON format, use serde for deserialization. 8) Sessions: keep JSONL format. 9) Memory: keep MEMORY.md/HISTORY.md file-based approach. 10) For WASM: no filesystem access directly, abstract behind trait. 11) CLI: clap for native, web API for WASM. 12) MCP: implement MCP client in Rust (mcp-rs or custom). Size target: <2MB WASM binary with wasm-opt."}],["entry_1771447460881_tana8g",{"id":"entry_1771447460881_tana8g","key":"project-overview","namespace":"clawft-knowledge","content":"clawft is a modular, async Rust framework for building AI assistants that connect to multiple messaging channels (Telegram, Slack, Discord) and LLM providers. The CLI binary is called 'weft'. The workspace at /home/aepod/dev/clawft/ contains 9 crates: clawft-types, clawft-platform, clawft-core, clawft-llm, clawft-tools, clawft-channels, clawft-services, clawft-cli, clawft-wasm. It features a 6-stage message processing pipeline, pluggable channel adapters, provider-agnostic LLM layer, tool system, MCP integration, session persistence, vector memory, cron jobs, security sandboxing, and WASM support. Rust edition 2024, MSRV 1.93, ~33,222 lines of Rust."}],["entry_1771447465882_7z66j",{"id":"entry_1771447465882_7z66j","key":"crate-dependency-graph","namespace":"clawft-knowledge","content":"Crate dependency graph (binary: weft): clawft-wasm --> clawft-types. clawft-platform --> clawft-types. clawft-llm --> (no clawft-* deps, standalone). clawft-core --> clawft-types, clawft-platform, clawft-llm. clawft-tools --> clawft-types, clawft-platform, clawft-core. clawft-channels --> clawft-types, clawft-platform. clawft-services --> clawft-types. clawft-cli --> all above (channels + services optional via feature flags). Feature flags: clawft-core has 'full' (default) and 'vector-memory'. clawft-tools has 'native-exec' (default). clawft-cli has 'channels' (default), 'services' (default), 'vector-memory'. Release profile: opt-level=z, LTO, strip, codegen-units=1, panic=abort."}],["entry_1771447472043_4upmli",{"id":"entry_1771447472043_4upmli","key":"workspace-structure","namespace":"clawft-knowledge","content":"Workspace structure at /home/aepod/dev/clawft/: crates/ contains 9 crates (clawft-types, clawft-platform, clawft-core, clawft-llm, clawft-tools, clawft-channels, clawft-services, clawft-cli, clawft-wasm). docs/ has 16 docs (~7072 lines) covering architecture, guides, deployment, reference, development. scripts/ has bench/ (benchmarks), build/ (cross-compile, docker), release/ (changelog, packaging). tests/ for integration tests. .planning/ has development_notes including codebase-map.md. .claude/ has CLAUDE.md project instructions. .github/ has CI workflows. Root has Cargo.toml (workspace manifest), Cargo.lock, rust-toolchain.toml (channel=1.93), Dockerfile (FROM scratch, static musl), README.md, CHANGELOG.md."}],["entry_1771447479837_tp8gl9",{"id":"entry_1771447479837_tp8gl9","key":"crate-types","namespace":"clawft-knowledge","content":"clawft-types: Core shared types crate with no heavy deps and no async runtime. Zero internal dependencies -- all other crates depend on it. Key types: Config, AgentsConfig, ChannelsConfig, ProvidersConfig, GatewayConfig, ToolsConfig, CommandPolicyConfig, UrlPolicyConfig, MCPServerConfig, ProviderSpec, LlmResponse, InboundMessage, OutboundMessage, Session, CronSchedule, CronJob, CronStore, ClawftError, ChannelError, ContentBlock, StopReason, Usage. Provider registry with 14 entries: custom, openrouter, aihubmix, anthropic, openai, openai_codex, deepseek, gemini, zhipu, dashscope, moonshot, minimax, vllm, groq. No feature flags. Deps: serde, serde_json, chrono, thiserror, uuid, dirs. Files: config.rs (1350L), provider.rs (571L), cron.rs (339L), error.rs (194L), session.rs (198L), event.rs (161L), lib.rs (22L). ~65 inline tests."}],["entry_1771447480585_ronk6",{"id":"entry_1771447480585_ronk6","key":"business-requirements","namespace":"clawft-knowledge","content":"clawft is a Rust rewrite of nanobot, a ~10K-line Python AI assistant framework supporting 9 chat channels, 14 LLM providers, tool system, memory/sessions, cron, and MCP. Goal: single static binary (weft) with <10MB RSS idle, <500ms cold start, feature-gated compilation. Standalone workspace at /home/aepod/dev/clawft/. MSRV: Rust 1.85+ (edition 2024). Binary targets: clawft-cli (weft), clawft-wasm. Deployment: native CLI <15MB stripped, WASM core <300KB gzipped. Success criteria: reads existing config.json, Telegram gateway works, all file/exec tools functional, session persistence via JSONL, channel plugin API stable. Config reads from ~/.clawft/ with fallback to ~/.nanobot/. Docker not required for basic operation. MIT license constraint on all deps."}],["entry_1771447485541_5g9bes",{"id":"entry_1771447485541_5g9bes","key":"crate-platform","namespace":"clawft-knowledge","content":"clawft-platform: Platform abstraction traits with native implementations enabling portability across native and WASM targets. Traits: Platform (bundles fs/env/http/process accessors), FileSystem (read_to_string, write_string, append_string, exists, list_dir, create_dir_all, remove_file, home_dir), HttpClient (request, get, post), Environment (get_var, set_var, remove_var), ProcessSpawner (returns Option for WASM compat). Native impls: NativePlatform, NativeFileSystem, NativeHttpClient, NativeEnvironment, NativeProcessSpawner. HttpResponse, ProcessOutput structs. ConfigLoader: discovers config via CLAWFT_CONFIG env, then ~/.clawft/config.json, then ~/.nanobot/config.json fallback. camelCase-to-snake_case key normalization. Deps: clawft-types, async-trait, reqwest, tokio, dirs. ~76 tests."}],["entry_1771447487931_e5t2pk",{"id":"entry_1771447487931_e5t2pk","key":"technical-architecture","namespace":"clawft-knowledge","content":"clawft uses a 6-stage pluggable pipeline: TaskClassifier -> ModelRouter -> ContextAssembler -> LlmTransport -> QualityScorer -> LearningBackend. Trait-based design with Platform trait bundle (HttpClient + FileSystem + Environment). 8-crate workspace: clawft-types (zero-dep), clawft-platform (I/O abstraction), clawft-core (agent loop, bus, context, memory, skills, sessions), clawft-tools, clawft-channels (plugin host), clawft-services (cron, heartbeat, MCP), clawft-cli, clawft-wasm. Feature flags: channel-telegram/slack/discord, tool-exec/web/spawn/cron, ruvector intelligence bundle. Config: serde with #[serde(default)], camelCase support, deep-merge hierarchy (defaults < global < project < env vars). Security: SSRF protection via UrlPolicy, command injection prevention via CommandPolicy, workspace containment, session ID validation, API key masking."}],["entry_1771447494203_aiqd6p",{"id":"entry_1771447494203_aiqd6p","key":"crate-core","namespace":"clawft-knowledge","content":"clawft-core: Central engine crate -- agent loop, message bus, session management, 6-stage pipeline, tool registry, context building, memory, embeddings, security. Pipeline stages: KeywordClassifier -> StaticRouter -> TokenBudgetAssembler -> OpenAiCompatTransport -> NoopScorer -> NoopLearner. Stage traits: TaskClassifier, ModelRouter, ContextAssembler, LlmTransport, QualityScorer, LearningBackend. PipelineRegistry maps TaskType (Chat, CodeGeneration, CodeReview, Research, Creative, Analysis, ToolUse, Unknown) to Pipeline instances. AgentLoop consumes MessageBus, builds context, invokes pipeline, executes tools. ContextBuilder assembles system prompt + skills + memory + history. MemoryStore manages MEMORY.md and HISTORY.md. SessionManager: JSONL persistence, write-through cache. Security: validate_session_id, sanitize_content, truncate_result (64KB). Bootstrap: AppContext wires all deps, enable_live_llm() replaces stub with ClawftLlmAdapter. Features: 'full' (default), 'vector-memory' (embeddings/HashEmbedder, vector_store/VectorStore, intelligent_router, session_indexer). Deps: clawft-types, clawft-platform, clawft-llm. ~239 inline tests + 3 external test files."}],["entry_1771447495601_atm72r",{"id":"entry_1771447495601_atm72r","key":"provider-architecture","namespace":"clawft-knowledge","content":"clawft-llm is a standalone library extracted from barni-providers (~10,563 lines). 4 native providers: Anthropic, OpenAI, Bedrock, Gemini. Config-driven OpenAiCompatProvider covers 14+ additional providers (Groq, DeepSeek, Mistral, OpenRouter, Together, Fireworks, Perplexity, xAI, Ollama, Azure) via configurable base_url. Prefix-based model routing (e.g. \"anthropic/claude-sonnet-4-20250514\"). 4 failover strategies: Sequential, WeightedRoundRobin, LowestLatency, CostOptimized. Lock-free CircuitBreaker (WASM-safe, atomics). Full SSE streaming with delta types. Tool calling fully modeled. Cost tracking with ModelCatalog pricing. Builder pattern for CompletionRequest. Provider trait is object-safe, async, Send+Sync. Optional litellm-rs sidecar for exotic non-OpenAI wire formats (Cohere, HuggingFace)."}],["entry_1771447497871_xk1qnl",{"id":"entry_1771447497871_xk1qnl","key":"development-phases","namespace":"clawft-knowledge","content":"clawft has 3 development phases named after weaving metaphors. Phase 1 \"Warp\" (Foundation) covers 3 streams: 1A (types, platform traits, plugin API), 1B (core engine -- MessageBus, SessionManager, MemoryStore, AgentLoop, ContextBuilder, ToolRegistry, SubagentManager), 1C (clawft-llm extraction, tools, Telegram plugin, CLI commands). Phase 2 \"Weft\" (Cross-threads) covers streams 2A (Slack + Discord channel plugins), 2B (RVF/ruvector integration -- vector memory, intelligent routing), 2C (services -- cron, heartbeat, MCP client, Codex OAuth), 2D (CLI completion -- channels status, cron commands, markdown conversion). Also includes 2I (security hardening -- CommandPolicy, UrlPolicy). Phase 3 \"Finish\" (WASM + CI/CD + Polish) covers 9 streams: 3A (WASM core), 3B (CI/CD + polish), 3C (Rust toolchain upgrade 1.85->1.93.1), 3D (WASI HTTP/FS + Docker -- DEFERRED to Phase 4), 3E (WASM allocator + size optimization), 3F (split: 3F-RVF for ruvector full integration, 3F-agents for skills/agents/commands), 3G (projects/workspaces), 3H (tool delegation + MCP server), 3I (gap analysis + fixes). Phase 4 planned for tiered routing + permission system with streams 4A-4D."}],["entry_1771447501936_j4eskl",{"id":"entry_1771447501936_j4eskl","key":"crate-llm","namespace":"clawft-knowledge","content":"clawft-llm: Standalone LLM provider abstraction with NO clawft-* dependencies. Purpose: unified interface for calling LLM APIs through OpenAI-compatible endpoints. Key types: Provider trait (complete(ChatRequest) -> ChatResponse), OpenAiCompatProvider (wraps reqwest::Client for any OpenAI-compat API), ProviderRouter (prefix-based routing, e.g. 'anthropic/claude-opus-4-5' -> strip prefix -> bare model to provider), ProviderConfig (base_url, api_key, headers), ChatRequest, ChatMessage, ChatResponse, ToolCall, Usage. 7 built-in providers: openai, anthropic, groq, deepseek, mistral, together, openrouter. Error handling: rate-limiting (429), auth (401/403), not-found (404). ClawftLlmAdapter bridges pipeline's LlmProvider trait (Value-based) to clawft-llm's typed Provider. Deps: async-trait, reqwest, serde, serde_json. Files: openai_compat.rs (342L), router.rs (330L), types.rs (322L), config.rs (214L), error.rs (121L). ~58 tests."}],["entry_1771447504841_2ygv0r",{"id":"entry_1771447504841_2ygv0r","key":"rvf-integration-plan","namespace":"clawft-knowledge","content":"RVF (RuVector Format) is clawft's intelligence layer. Single .rvf file stores agent memory embeddings, session state, routing policies, and runs queries via 5.5KB WASM microkernel. Key segments: VEC (embeddings), INDEX (HNSW), POLICY_KERNEL (routing policy), COST_CURVE (provider cost/latency/quality), WITNESS (audit trail). Progressive 3-tier HNSW: Layer A ~70% recall in microseconds, B ~85%, C ~95%. Auto-tiering: hot=fp16 (768B/vec), warm=PQ (48B, 16x compression), cold=binary (48B, 32x compression). 10K entries at 20/30/50 distribution = ~2MB total. Integration: MemoryStore uses RvfVectorStore for semantic search, SessionManager indexes summaries, IntelligentRouter uses POLICY_KERNEL+COST_CURVE. WASM: rvf-wasm microkernel <8KB, no_std, 14 C-ABI exports. Binary impact: minimal ~260KB, full ~330KB."}],["entry_1771447508703_dubv1e",{"id":"entry_1771447508703_dubv1e","key":"development-status","namespace":"clawft-knowledge","content":"As of 2026-02-17: Phase 1 (Warp) and Phase 2 (Weft) are COMPLETE. Phase 3 (Finish) is approximately 85% complete. Streams 2I (security), 3A (WASM core -- conditional pass, infrastructure done, real WASI impls deferred), 3B (CI/CD -- pass, 95%), and 3C (Rust toolchain upgrade to 1.93.1 -- 90%) are done or nearly done. The codebase has 9 crates, ~121 Rust source files, 1,058 tests (0 failures, 8 ignored), 0 clippy warnings. Performance: 3.5ms startup (229x faster than Python), 4.6MB binary (43x smaller than Python 200+MB). Remaining Phase 3 work includes streams 3D-3I implementation (skills, agents, workspaces, MCP server, delegation, RVF integration, gap fixes). 3D (WASI HTTP/FS + Docker) has been deferred to Phase 4. All 7 SPARC plans for 3D-3I were reviewed by expert reviewers; 6 received APPROVE_WITH_CHANGES, 1 (3F-RVF) received REVISE (40% overscoped, reduced from 44 to 32 engineer-days). All P0 pre-implementation blockers resolved. RVF/ruvector integration has NOT started -- all intelligence levels (L0-L5) remain unimplemented. Git commit 0985fb6 on master branch is latest."}],["entry_1771447509271_zwywre",{"id":"entry_1771447509271_zwywre","key":"crate-tools","namespace":"clawft-knowledge","content":"clawft-tools: Tool implementations for file I/O, shell, memory, web, spawning. All security-gated. Registered tools: read_file, write_file, edit_file, list_directory (all workspace-sandboxed via file_tools.rs 782L), memory_read, memory_write (memory_tool.rs 435L), web_search (web_search.rs 216L), web_fetch (web_fetch.rs 179L, SSRF protection + body size limits), exec_shell (shell_tool.rs 415L, workspace CWD), spawn (spawn_tool.rs 293L, sub-agent processes), message (message_tool.rs 190L). Security: security_policy.rs (405L) for command policies, url_safety.rs (496L) for URL validation/SSRF prevention. register_all(registry, platform, workspace_dir) registers all tools with path containment. Feature: 'native-exec' (default) gates shell_tool and spawn_tool. Deps: clawft-types, clawft-platform, clawft-core. ~136 inline tests + 1 external test file (655L)."}],["entry_1771447512311_d3y7q",{"id":"entry_1771447512311_d3y7q","key":"workspace-system","namespace":"clawft-knowledge","content":"Workspace system provides project isolation. Global workspace at ~/.clawft/ (user-wide config, skills, sessions, memory). Project workspace at .clawft/ in project root (project-specific overrides). CLAWFT.md at workspace root provides persistent project-specific context to agent (analogous to CLAUDE.md). Config hierarchy: built-in defaults < global ~/.clawft/config.json < project .clawft/config.json < $CLAWFT_* env vars. Deep merge: scalars=project wins, objects=recursive merge, arrays=replace, null=remove. Skills discovery chain: project skills > user skills > global skills (union with precedence). Workspace discovery: --workspace flag > $CLAWFT_WORKSPACE > cwd walk-up for .clawft/ > global fallback. MCP Mode 1: weft mcp-server exposes tools to Claude Code/claude-flow. MCP Mode 2: clawft connects to external MCP servers. weft init scaffolds .clawft/ with config.json, skills/, memory/, agents/."}],["entry_1771447516422_bmvig7",{"id":"entry_1771447516422_bmvig7","key":"crate-channels","namespace":"clawft-knowledge","content":"clawft-channels: Plugin-based chat channel system for Telegram, Slack, Discord. Key traits: Channel (name, metadata, status, is_allowed, start, send -> MessageId), ChannelHost (deliver_inbound, register_command, publish_inbound), ChannelFactory (creates Channel instances from JSON config). Key struct: PluginHost manages Vec<Arc<dyn Channel>> lifecycle -- factory registration, channel init from config, start/stop via CancellationToken + JoinHandle, outbound routing. ChannelMetadata has name, display_name, supports_threads, supports_media. ChannelStatus: Stopped/Starting/Running/Error/Stopping. Transports: Telegram uses HTTP long-polling + REST (channel.rs, client.rs, types.rs). Slack uses Socket Mode WebSocket + REST (channel.rs, api.rs, events.rs, signature.rs). Discord uses Gateway WebSocket + REST (channel.rs, api.rs, events.rs). Deps: clawft-types, clawft-platform, async-trait, tokio, tokio-tungstenite. ~118 inline tests + 3 external files (1091L)."}],["entry_1771447518695_gn93b",{"id":"entry_1771447518695_gn93b","key":"tiered-router","namespace":"clawft-knowledge","content":"TieredRouter (ADR-026) replaces StaticRouter when routing.mode=\"tiered\" in config. Combines 3 inputs: task complexity (from TaskClassifier), user permissions (from channel auth), cost constraints (from budget tracking). 3 permission levels: zero-trust (free models only, no tools, 10rpm, no streaming/escalation), user (free+standard, basic tools, 60rpm, escalation at 0.6 complexity), admin (all tiers, all tools, unlimited). 4 model tiers: free ($0, complexity 0-0.3), standard ($0.001/1K, 0-0.7), premium ($0.01/1K, 0.3-1.0), elite ($0.05/1K, 0.7-1.0). Per-user overrides via channel-prefixed IDs (discord:123, slack:U04ABC). Cost budgets: daily/monthly USD caps with auto-fallback. Escalation: complexity-triggered tier promotion. Backward-compatible: absent routing section uses StaticRouter unchanged."}],["entry_1771447519592_8zacao",{"id":"entry_1771447519592_8zacao","key":"api-types-public","namespace":"clawft-knowledge","content":"clawft-types is the foundation crate of the dependency graph -- all other clawft crates depend on it. It exposes 8 public modules: config (configuration schema ported from Python schema.py), cron (scheduled job types), delegation (task delegation routing), error (ClawftError and ChannelError), event (inbound/outbound message events), provider (LLM response types and 14-provider registry), session (conversation session state), skill (skill definitions), workspace (workspace types). The crate re-exports from error: ChannelError, ClawftError, and the Result type alias. File: crates/clawft-types/src/lib.rs"}],["entry_1771447525628_vcecsd",{"id":"entry_1771447525628_vcecsd","key":"security-requirements","namespace":"clawft-knowledge","content":"clawft security boundaries: SSRF protection via UrlPolicy (restricts outbound HTTP from tools like web_fetch/web_search to approved domains/patterns). Command injection prevention via CommandPolicy (exec tool validates commands against allowlist/denylist, timeout enforcement). Session ID validation prevents path traversal in session file access. Workspace containment: file tools restricted to allowed_paths (config.tools.allowed_paths), defaults to workspace directory only. Symlink protection: file operations resolve symlinks and verify target is within allowed paths. API key masking: keys in logs/errors are redacted. Tool result truncation prevents memory exhaustion from large outputs. Permission system: zero-trust default for unidentified users, tool_deny overrides tool_access, MCP server mode inherits caller's permission level (not admin default). Rate limiting per permission level. Cost budget enforcement with automatic fallback to cheaper models."}],["entry_1771447525926_fmvegg",{"id":"entry_1771447525926_fmvegg","key":"api-config-structure","namespace":"clawft-knowledge","content":"The Config struct (crates/clawft-types/src/config.rs) is the root configuration, a faithful port of Python nanobot/config/schema.py. All structs support both snake_case and camelCase field names via #[serde(alias)] and ignore unknown fields for forward compatibility. Root fields: agents (AgentsConfig), channels (ChannelsConfig), providers (ProvidersConfig), gateway (GatewayConfig), tools (ToolsConfig), delegation (DelegationConfig). Config has a workspace_path() method that expands ~ to home dir. AgentsConfig contains defaults (AgentDefaults). AgentDefaults fields: workspace (default \"~/.nanobot/workspace\"), model (default model string), max_tokens (alias maxTokens), temperature, max_tool_iterations (alias maxToolIterations), memory_window (alias memoryWindow). All fields have sensible defaults. File: crates/clawft-types/src/config.rs"}],["entry_1771447526422_2b5s19",{"id":"entry_1771447526422_2b5s19","key":"crate-services","namespace":"clawft-knowledge","content":"clawft-services: Background services -- cron, heartbeat, MCP client/server. CronService: JSONL-backed scheduled job execution using cron expressions, jobs fire as InboundMessage on the bus (cron_service/mod.rs, scheduler.rs, storage.rs). HeartbeatService: periodic health check messages at configurable intervals (heartbeat/mod.rs). MCP subsystem (mcp/): Dual-mode -- Server mode ('weft mcp-server') via McpServerShell exposes tools over JSON-RPC stdio. Client mode (tools.mcp_servers config) via McpClient connects to external MCP servers. ToolProvider trait with namespace(), list_tools(), call_tool(). Providers: BuiltinToolProvider (wraps ToolRegistry), RvfToolProvider (11 RVF vector tools), ProxyToolProvider (external MCP), DelegationToolProvider (Claude bridge). CompositeToolProvider aggregates with {server}__{tool} namespace routing. Middleware: SecurityGuard, PermissionFilter, ResultGuard, AuditLog. Transports: StdioTransport, HttpTransport, MockTransport. Protocol: MCP 2025-06-18, newline-delimited JSON-RPC. Deps: clawft-types, async-trait, serde, cron, tokio. ~28 tests."}],["entry_1771447527318_2s7npq",{"id":"entry_1771447527318_2s7npq","key":"phase3-streams","namespace":"clawft-knowledge","content":"Phase 3 streams detail: 3A (WASM Core) -- CONDITIONAL PASS at ~75%. clawft-wasm crate exists, builds for wasm32-wasip1, 41 tests, decoupled from core/platform, uses dlmalloc allocator. Real WASI HTTP/FS are stubs only; deferred to Phase 4. rlib output is 142KB. 3B (CI/CD + Polish) -- PASS at ~95%. 4 GitHub Actions workflows (ci, release, wasm-build, benchmarks), Dockerfile (FROM scratch), 13 shell scripts (bench, build, release), CHANGELOG, deployment docs, CLI integration tests (29), security integration tests (33). 3C (Rust Toolchain Upgrade) -- IN PROGRESS at ~90%. Upgrading from 1.85 to 1.93.1, fixed clippy lints (let_and_return, derivable_impls, collapsible_if across 12 files), wasm-build.yml updated for wasip2 primary. 3D (WASI HTTP/FS + Docker Multi-Arch) -- DEFERRED TO PHASE 4 per consensus review; needs more research on wasi-http-client maturity and component model. 3E (WASM Allocator + Size Optimization) -- approved, allocator comparison + wasm-opt pipeline planned. Empirical baseline: 57.9KB raw / 24.3KB gzipped cdylib. Budget: 300KB/120KB. 3F-RVF (RVF/ruvector Full Integration) -- REVISED, reduced to 32 engineer-days (6 sprints). Sprint 0 validation PASSED: all 11 ruvector crates compile on 1.93.1. Delivers L0-L1 intelligence; L2-L4 deferred. 3F-agents (Skills, Agents, Commands) -- approved. Multi-directory skill discovery (3-level chain: project > user > workspace), agent definitions, slash commands, CLI commands. Security hardening added (SEC-SKILL-01 through 07). 3G (Projects/Workspaces) -- approved (highest score 4.6/5). Config deep-merge, workspace discovery, weft init command, project-scoped config. 3H (Tool Delegation + MCP Server) -- approved. Pluggable ToolProvider architecture in clawft-services/src/mcp/ with McpServerShell, middleware pipeline (SecurityGuard, PermissionFilter, ResultGuard, AuditLog), CompositeToolProvider. weft mcp-server command. 3I (Gap Analysis + Fixes) -- approved, re-baselined to 8 P0 gaps (down from 12). Key gaps: SSE streaming (GAP-11), web search config (GAP-03), JSON repair (GAP-14), circuit breaker/retry (GAP-18), memory wiring (GAP-15), onboard command (GAP-12)."}],["entry_1771447532204_7zuyt",{"id":"entry_1771447532204_7zuyt","key":"api-error-types","namespace":"clawft-knowledge","content":"Error types in crates/clawft-types/src/error.rs. Uses thiserror. ClawftError is #[non_exhaustive] with two categories: RECOVERABLE: Retry { source, attempts }, Timeout { operation }, Provider { message }, RateLimited { retry_after_ms }. FATAL: ConfigInvalid { reason }, PluginLoadFailed { plugin }, Io(std::io::Error via #[from]), Json(serde_json::Error via #[from]), Channel(String), SecurityViolation { reason }. ChannelError is also #[non_exhaustive] with variants: ConnectionFailed, AuthFailed, SendFailed, ReceiveFailed, NotConnected, NotFound, Other. The crate provides type alias Result<T> = std::result::Result<T, ClawftError>. Both error types are grouped to guide callers on whether retrying is worthwhile."}],["entry_1771447533202_m1x5g",{"id":"entry_1771447533202_m1x5g","key":"crate-cli","namespace":"clawft-knowledge","content":"clawft-cli: The 'weft' binary. CLI commands wrapping the full stack. Subcommands: agent (interactive session or single message via -m), gateway (start channels + agent loop), status (config diagnostics), channels (channel management), cron (scheduled job CRUD: list/add/enable/run), sessions (list/inspect/delete), memory (show/history/search), config (show/section), completions (bash/zsh/fish shell completions). Markdown dispatch: telegram.rs, slack.rs, discord.rs for per-channel rendering using pulldown-cmark to styled output. Feature flags: 'channels' (default, pulls clawft-channels), 'services' (default, pulls clawft-services), 'vector-memory' (propagates to clawft-core for semantic search). Deps: all workspace crates, clap (derive), tokio, tracing-subscriber, pulldown-cmark, comfy-table. ~223 inline tests + 1 external test file (cli_integration.rs, 542L)."}],["entry_1771447533743_844p5",{"id":"entry_1771447533743_844p5","key":"tools-implementation","namespace":"clawft-knowledge","content":"clawft-tools crate (crates/clawft-tools/src/lib.rs) provides all built-in tool implementations. The register_all() function accepts a ToolRegistry, Platform, workspace_dir, CommandPolicy, UrlPolicy, and WebSearchConfig, then registers 10 tools: ReadFileTool, WriteFileTool, EditFileTool, ListDirectoryTool (file_tools module), ShellExecTool (shell_tool, feature-gated on native-exec), MemoryReadTool, MemoryWriteTool (memory_tool), WebSearchTool (web_search), WebFetchTool (web_fetch, gated by UrlPolicy for SSRF protection), and SpawnTool (spawn_tool, feature-gated on native-exec). File tools enforce workspace path containment via validate_path() which canonicalizes paths and verifies they remain within workspace_dir. A separate validate_parent_path() handles write operations to not-yet-existing files by walking ancestor directories. Additional modules: security_policy (CommandPolicy), url_safety (UrlPolicy), message_tool, delegate_tool (feature-gated on delegate). The crate is ported from Python nanobot/agent/tools/filesystem.py."}],["entry_1771447536537_i6md09",{"id":"entry_1771447536537_i6md09","key":"sparc-methodology","namespace":"clawft-knowledge","content":"clawft uses the SPARC methodology: Specification (requirements and goals), Pseudocode (algorithmic design), Architecture (system design and interfaces), Refinement (review and iteration), Completion (implementation and testing). Each Phase 3 stream (3D through 3I) has a SPARC plan document in .planning/sparc/ directory. Expert reviews are in .planning/reviews/ -- 7 independent reviewers produced ~2,069 lines of review across 7 plans, coordinated into a consensus document (.planning/reviews/consensus.md). Development notes are organized under .planning/development_notes/ with per-phase subdirectories (e.g., .planning/development_notes/phase3/). Key planning files: .planning/01-business-requirements.md, .planning/02-technical-requirements.md, .planning/03-development-guide.md, .planning/04-rvf-integration.md, .planning/05-ruvector-crates.md. The consolidated planning summary is at .planning/development_notes/planning-summary.md. Phase 3 used 4 rounds of parallel swarm execution (8 agents per round) tracked in round1-summary.md through round4-summary.md. A Sprint 0 validation gate was added for 3F-RVF to validate external ruvector dependencies before committing implementation effort. The review process identified 14 critical issues, 22 major issues, and 28 minor issues across all plans, plus 11 cross-phase conflicts (most now resolved)."}],["entry_1771447537934_8th27k",{"id":"entry_1771447537934_8th27k","key":"api-platform-traits","namespace":"clawft-knowledge","content":"Platform abstraction layer in crates/clawft-platform/src/lib.rs. Provides traits for all platform-dependent operations so core can be platform-agnostic and WASM-compatible. Modules: config_loader, env, fs, http, process. The Platform trait (async_trait, Send+Sync) bundles: http() -> &dyn HttpClient, fs() -> &dyn FileSystem, env() -> &dyn Environment, process() -> Option<&dyn ProcessSpawner>. ProcessSpawner returns Option because it is unavailable in WASM. NativePlatform is the concrete implementation using reqwest (HTTP with connection pooling + TLS), tokio::fs, std::env, and tokio::process. NativePlatform implements Default. The crate enforces Send+Sync bounds on all platform types."}],["entry_1771447539361_uzwtzs",{"id":"entry_1771447539361_uzwtzs","key":"crate-wasm","namespace":"clawft-knowledge","content":"clawft-wasm: WASM entrypoint targeting wasm32-wasip1 and wasip2. Provides a WASM-compatible surface for clawft types and future browser API platform implementation. Currently Phase 3A stub -- pipeline NOT wired, contains stubs for HTTP (fetch API planned), FS (WASI/in-memory backends), env, and platform. ProcessSpawner returns None (no process spawning in WASM). Minimal deps: clawft-types only, plus serde, serde_json, dlmalloc (wasm32 allocator). Files: fs.rs (165L), env.rs (155L), platform.rs (146L), http.rs (134L), lib.rs (119L), allocator.rs (8L). Phase 3D planned to add real implementations replacing stubs. ~41 inline tests."}],["entry_1771447542211_x8vnl",{"id":"entry_1771447542211_x8vnl","key":"security-implementation","namespace":"clawft-knowledge","content":"Security implementation in clawft-tools/src/security_policy.rs. CommandPolicy struct has fields: mode (PolicyMode::Allowlist or Denylist), allowlist (HashSet of permitted basenames), denylist (Vec of blocked patterns), dangerous_patterns (Vec, always checked regardless of mode). Default allowlist: 17 read-only commands (echo, cat, ls, pwd, head, tail, wc, grep, find, sort, uniq, diff, date, env, true, false, test). Default dangerous patterns: 11 patterns always blocked (rm -rf /, sudo, mkfs, dd if=, fork bomb, chmod 777 /, > /dev/sd, shutdown, reboot, poweroff, format c:). PolicyError variants: NotAllowed, Blocked, DangerousPattern. Validation flow: dangerous patterns checked first (defense-in-depth), then mode-specific check. Basename extraction strips path prefix from first token. UrlPolicy (url_safety.rs) provides SSRF protection: blocks private networks (10/8, 172.16/12, 192.168/16), loopback (127/8, ::1), link-local (169.254/16, fe80::/10), ULA (fc00::/7), and cloud metadata endpoints (169.254.169.254, metadata.google.internal). Supports allowedDomains (bypass all checks) and blockedDomains. File tools enforce workspace containment via path canonicalization. Tool results are truncated at 64KB. Session IDs are validated."}],["entry_1771447545438_ffx63o",{"id":"entry_1771447545438_ffx63o","key":"api-core-bootstrap","namespace":"clawft-knowledge","content":"AppContext bootstrap in crates/clawft-core/src/bootstrap.rs. AppContext<P: Platform> is the fully initialized application context. It holds: config (Config), platform (Arc<P>), bus (Arc<MessageBus>), sessions (SessionManager<P>), tools (ToolRegistry), pipeline (PipelineRegistry), context (ContextBuilder<P>), memory (Arc<MemoryStore<P>>), skills (Arc<SkillsLoader<P>>). Constructor AppContext::new(config, platform) initializes in order: 1) MessageBus, 2) SessionManager (discovers/creates sessions dir), 3) MemoryStore (discovers memory dir), 4) SkillsLoader (discovers skills dir), 5) ContextBuilder, 6) empty ToolRegistry (caller registers tools after), 7) default Level 0 pipeline with KeywordClassifier, StaticRouter, TokenBudgetAssembler, OpenAiCompatTransport stub, NoopScorer, NoopLearner. Consumed via into_agent_loop() which returns an AgentLoop ready to run. Usage: let ctx = AppContext::new(config, Arc::new(NativePlatform::new())).await?; let loop = ctx.into_agent_loop();"}],["entry_1771447548870_id7k1i",{"id":"entry_1771447548870_id7k1i","key":"known-gaps","namespace":"clawft-knowledge","content":"Known gaps from 3I gap analysis (re-baselined to 8 P0 items, down from original 12 after GAP-01, GAP-02, GAP-06 found already resolved in code, GAP-16 demoted to P2). P0 gaps: GAP-11 (SSE streaming -- add complete_stream() to LlmTransport trait, implement SSE parsing, wire through pipeline to CLI/channel output; hardest single item, estimated 6h but could expand to 2-3 days), GAP-03 (web search config wiring -- pass ToolsConfig into register_all(), wire Brave endpoint from config, inject API key as HTTP header), GAP-14 (JSON repair -- handle malformed LLM output), GAP-18 (circuit breaker/retry/failover -- implement retry logic with backoff), GAP-15 (VectorStore memory wiring -- MemoryStore uses placeholder HashEmbedder, needs VectorStore trait integration), GAP-12 (weft onboard command -- setup wizard for initial configuration), GAP-17 (tool call parsing verification). Sprint plan: Day 1 = SSE streaming + web search fix; Day 2 = JSON repair + retry + onboard; Day 3 = memory wiring + tool parsing + tests; Day 4 = P1 security items + docs + smoke tests. P1 security gaps: SEC-04 (API key logging), SEC-05 (symlink traversal), MISSED-05 (web_fetch body size limit). Additional outstanding requirements: RVF/ruvector integration (all intelligence levels L0-L5 unimplemented), Anthropic/Bedrock/Gemini dedicated provider modules (only OpenAI-compat exists), real WASI HTTP/FS implementations, end-to-end Telegram/CLI verification with real APIs, WASM runtime validation (wasmtime, WAMR)."}],["entry_1771447551488_rrr2ba",{"id":"entry_1771447551488_rrr2ba","key":"mcp-client-implementation","namespace":"clawft-knowledge","content":"MCP client implementation in clawft-services/src/mcp/mod.rs. Submodules: composite, middleware, provider, server, transport, types. Re-exports from provider: BuiltinToolProvider, CallToolResult, ContentBlock, ToolError, ToolProvider. McpClient struct wraps a Box<dyn McpTransport> and AtomicU64 request_id counter. Methods: new(transport), list_tools() sends JSON-RPC \"tools/list\" and parses Vec<ToolDefinition>, call_tool(name, params) sends \"tools/call\" with name+arguments, send_raw(method, params) for arbitrary JSON-RPC, transport() accessor. ToolDefinition has name, description, input_schema (supports both camelCase inputSchema and snake_case input_schema). McpSession wraps McpClient and performs 3-step initialize handshake: (1) sends \"initialize\" with protocolVersion \"2025-06-18\" and client capabilities, (2) parses ServerCapabilities and ServerInfo, (3) sends \"notifications/initialized\". Holds server_capabilities, server_info, protocol_version. Transports: StdioTransport (child process stdin/stdout), HttpTransport (Streamable HTTP), MockTransport (testing). All operations return Result<T, ServiceError> with McpProtocol variant for JSON-RPC errors."}],["entry_1771447552373_nuwe9a",{"id":"entry_1771447552373_nuwe9a","key":"api-pipeline-system","namespace":"clawft-knowledge","content":"6-stage pipeline system in crates/clawft-core/src/pipeline/traits.rs. Each stage has a trait with Level 0/1/2 capability tiers. Stages: 1) TaskClassifier::classify(&ChatRequest) -> TaskProfile (task_type: TaskType enum [Chat, CodeGeneration, CodeReview, Research, Creative, Analysis, ToolUse, Unknown], complexity: f32, keywords: Vec<String>). 2) ModelRouter::route(&ChatRequest, &TaskProfile) -> RoutingDecision (provider, model, reason) + update() for adaptive learning. 3) ContextAssembler::assemble(&ChatRequest, &TaskProfile) -> AssembledContext (messages, token_estimate, truncated). 4) LlmTransport::complete(&TransportRequest) -> LlmResponse + complete_stream() with StreamCallback. 5) QualityScorer::score(&ChatRequest, &LlmResponse) -> QualityScore (overall, relevance, coherence -- all 0.0-1.0). 6) LearningBackend::record(&Trajectory) + adapt(&LearningSignal). Pipeline struct bundles all 6 Arc<dyn Trait>. PipelineRegistry maps TaskType -> Pipeline with a default fallback. PipelineRegistry::complete() orchestrates: classify -> select pipeline -> route -> assemble -> transport -> score -> learn."}],["entry_1771447558275_ztag7s",{"id":"entry_1771447558275_ztag7s","key":"api-tool-registry","namespace":"clawft-knowledge","content":"Tool registry in crates/clawft-core/src/tools/registry.rs. Defines ToolError enum: NotFound, InvalidArgs, ExecutionFailed, PermissionDenied, FileNotFound, InvalidPath, Timeout(u64 seconds). Tool trait (async_trait, Send+Sync): name() -> &str, description() -> &str, parameters() -> serde_json::Value (JSON Schema for OpenAI function calling), execute(args: serde_json::Value) -> Result<serde_json::Value, ToolError>. ToolRegistry stores HashMap<String, Arc<dyn Tool>>. Methods: new() (empty), register(Arc<dyn Tool>) (replaces if same name), get(name) -> Option<Arc<dyn Tool>>, list() -> Vec<String> (sorted alphabetically), schemas() -> Vec<serde_json::Value> (OpenAI function calling format: {type: \"function\", function: {name, description, parameters}}). Tool implementations live in clawft-tools crate; this module only defines the contract and registry infrastructure."}],["entry_1771447558759_1zf1z",{"id":"entry_1771447558759_1zf1z","key":"test-inventory","namespace":"clawft-knowledge","content":"Test inventory as of Phase 3 Round 4: 1,058 total tests (0 failures, 8 ignored), 0 clippy warnings. Test progression: Phase 2 complete = 892, Round 1 = 960 (+68, security policy + WASM skeleton), Round 2 = 1,029 (+69, WASM platform stubs + feature flags + CI), Round 3 = 1,048 (+19, CLI integration + benchmarks + metadata), Round 4 = 1,058 (+10, WASM crate tests + CI hardening). External test files: tests/cli_integration.rs (29 tests, using assert_cmd for end-to-end binary invocation), tests/security_integration.rs (33 tests for CommandPolicy/UrlPolicy enforcement). clawft-wasm has 41 unit tests. Coverage spans all 9 crates. Unit tests cover: config deserialization, platform traits (HTTP, FS, env, process), message bus, session management, memory store, skills loader, pipeline stages (classifier, router, assembler, transport, scorer, learner), tool registry and individual tools (file, shell, web, message, spawn), channel plugins (Telegram, Slack, Discord), services (cron, heartbeat, MCP), CLI argument parsing, WASM platform stubs. No phase1_integration.rs or phase2_integration.rs external test files were found in the read files -- these may be inline within crate test modules. Key testing decisions: London School TDD (mock-first), assert_cmd for CLI integration tests, mock ChannelHost for plugin tests."}],["entry_1771447561264_oskzpi",{"id":"entry_1771447561264_oskzpi","key":"cli-commands","namespace":"clawft-knowledge","content":"CLI binary 'weft' defined in clawft-cli/src/main.rs using clap (Parser, Subcommand). Global flag: --verbose/-v for debug logging. Top-level Commands enum with 15 subcommands: Agent (interactive REPL or single message via -m, --model override, --intelligent-routing), Gateway (start channels + agent loop), McpServer (MCP tool server over stdio), Status (system diagnostics, --detailed), Channels { status } (inspect channel config), Cron { list, add, remove, enable, disable, run } (scheduled jobs), Sessions { list, inspect, delete } (conversation sessions), Memory { show, history, search } (MEMORY.md/HISTORY.md, vector search with --limit), Config { show, section } (resolved config as JSON), Skills (list, show, install), Agents (list, show, use), Workspace (create, list, load, status, delete, config set/get/reset), Onboard (initial setup wizard, --yes, --dir), Help (topic-based: skills, agents, tools, commands, config), Completions (bash, zsh, fish, powershell). Internal modules: commands, completions, help_text, interactive, markdown, mcp_tools. All subcommands accept --config/-c for config path override."}],["entry_1771447564375_8cvag3",{"id":"entry_1771447564375_8cvag3","key":"api-agent-loop","namespace":"clawft-knowledge","content":"AgentLoop in crates/clawft-core/src/agent/loop_core.rs. Ported from Python nanobot/agent/loop.py. AgentLoop<P: Platform> holds: config (AgentsConfig), platform (Arc<P>), bus (Arc<MessageBus>), pipeline (PipelineRegistry), tools (ToolRegistry), context (ContextBuilder<P>), sessions (SessionManager<P>). Processing flow: 1) Consume InboundMessage from MessageBus, 2) Session lookup/creation keyed by channel:chat_id, 3) ContextBuilder.build_messages() to assemble LLM prompt, 4) Pipeline execution (Classifier -> Router -> Assembler -> Transport -> Scorer -> Learner), 5) Tool execution loop up to max_tool_iterations -- extract tool calls from LLM response, execute via ToolRegistry, append results to context, re-invoke LLM if stop_reason == ToolUse, 6) Dispatch OutboundMessage to bus, 7) Persist updated session. MAX_TOOL_RESULT_BYTES = 65536 for truncation of oversized tool results."}],["entry_1771447571644_5m9zo",{"id":"entry_1771447571644_5m9zo","key":"api-llm-provider","namespace":"clawft-knowledge","content":"clawft-llm crate (crates/clawft-llm/src/lib.rs) is a standalone LLM provider library with NO dependencies on other clawft crates. Modules: config, error, failover, openai_compat, provider, retry, router, sse, types. Public re-exports: ProviderConfig (connection config), ProviderError + Result, FailoverChain (provider failover), OpenAiCompatProvider (implements Provider for any OpenAI-compatible API), Provider trait (chat completion interface), RetryConfig + RetryPolicy, ProviderRouter (routes model names like \"openai/gpt-4o\" to providers), parse_sse_line (SSE stream parsing), ChatMessage + ChatRequest + ChatResponse + StreamChunk + ToolCall + Usage (types). Usage: ProviderRouter::with_builtins() creates router, router.route(\"openai/gpt-4o\") returns (provider, model_name), then provider.complete(&request).await returns ChatResponse."}],["entry_1771447572762_v43i3g",{"id":"entry_1771447572762_v43i3g","key":"docs-configuration","namespace":"clawft-knowledge","content":"Configuration guide (docs/guides/configuration.md). Single JSON config file with 3-step discovery: (1) CLAWFT_CONFIG env var, (2) ~/.clawft/config.json, (3) ~/.nanobot/config.json (legacy fallback). Accepts both snake_case and camelCase keys. Sections: agents.defaults (model as provider/model syntax, workspace, max_tokens 8192, temperature 0.7, max_tool_iterations 20, memory_window 50), providers (anthropic, openai, openrouter, deepseek, groq, zhipu, dashscope, vllm, gemini, moonshot, minimax, aihubmix, openai_codex, custom -- each with api_key, api_base, extra_headers), channels (telegram with token/allow_from/proxy, slack with socket mode/bot_token/app_token/group_policy/dm config, discord with token/intents/gateway_url; also WhatsApp, Feishu, DingTalk, Email, QQ), gateway (host, port 18790, heartbeat settings), tools (restrict_to_workspace, web.search api_key/max_results, exec.timeout, commandPolicy mode/allowlist/denylist, urlPolicy enabled/allowPrivate/allowedDomains/blockedDomains), tools.mcp_servers (stdio transport: command/args/env, HTTP transport: url, tool namespacing by server name). Feature flags: vector-memory (enables IntelligentRouter, VectorStore, SessionIndexer). Environment variables for provider API keys and RUST_LOG."}],["entry_1771447582818_07l77g",{"id":"entry_1771447582818_07l77g","key":"docs-providers","namespace":"clawft-knowledge","content":"Providers guide (docs/guides/providers.md). Pluggable provider system in clawft-llm crate (no dependencies on other clawft crates). All providers use OpenAI-compatible chat completions API format (POST /v1/chat/completions). Prefix-based routing via ProviderRouter: model identifiers like \"anthropic/claude-sonnet-4-5-20250514\" are split at first slash, prefix selects provider, remainder is model name sent to API. Longest-prefix-first matching. 7 built-in providers via ProviderRouter::with_builtins(): openai (api.openai.com), anthropic (api.anthropic.com, adds anthropic-version header), groq, deepseek, mistral, together, openrouter. Each needs only one env var. Config overrides: api_base, extra_headers per provider. Custom providers via ProviderConfig struct (name, base_url, api_key_env, model_prefix, default_model, headers) or by implementing the Provider trait directly for non-OpenAI protocols. ProviderError enum: RequestFailed, AuthFailed, RateLimited (with retry_after_ms), ModelNotFound, NotConfigured, InvalidResponse, Timeout, Http, Json. API keys resolved at request time from env vars, never persisted. Local LLM support: Ollama, llama.cpp, vLLM via api_base override. Debug impl redacts API keys."}],["entry_1771447594652_3t90co",{"id":"entry_1771447594652_3t90co","key":"docs-skills-agents","namespace":"clawft-knowledge","content":"Skills and agents guide (docs/guides/skills-and-agents.md). Skills are reusable LLM instruction bundles. Preferred format: SKILL.md with YAML frontmatter (name, description, version, variables, allowed-tools, user-invocable, disable-model-invocation, argument-hint) and markdown body with {{variable}} template syntax. Legacy format: skill.json + prompt.md in a directory. SKILL.md takes precedence if both exist. Discovery chain (highest priority first): workspace (.clawft/skills/), user (~/.clawft/skills/), built-in. CLI: weft skills list/show/install. Interactive: /skills, /use <name>, /use (deactivate). Security controls: SEC-SKILL-01 (YAML nesting depth limit 10), SEC-SKILL-02 (directory path traversal validation), SEC-SKILL-03 (tool intersection when both skill and agent declare allowed_tools), SEC-SKILL-05 (workspace skills not loaded by default, require --trust-project-skills), SEC-SKILL-06 (prompt injection token stripping: <system>, <|im_start|>, <<SYS>>), SEC-SKILL-07 (50KB size limit). Agents are predefined personas with agent.yaml/yml/json format (name, description, model, system_prompt, skills, allowed_tools, max_turns, variables). Same 3-level discovery. Template variables: $ARGUMENTS, ${1}/${2} positional, ${NAME} from variables map. CLI: weft agents list/show/use. Interactive: /agent <name>. Agent files limited to 10KB, model strings validated against shell metacharacters."}],["entry_1771447601941_6ta26",{"id":"entry_1771447601941_6ta26","key":"docs-security","namespace":"clawft-knowledge","content":"Security reference (docs/reference/security.md). Defense-in-depth approach with 5 layers: (1) Command Execution Policy -- CommandPolicy with allowlist mode (default, recommended, 17 safe read-only commands) or denylist mode. 11 dangerous patterns always blocked regardless of mode (rm -rf /, sudo, mkfs, dd if=, fork bomb, chmod 777 /, > /dev/sd, shutdown, reboot, poweroff, format c:). Basename extraction strips path prefix. (2) URL Safety / SSRF Protection -- UrlPolicy validates URLs before web_fetch. Blocks private networks (10/8, 172.16/12, 192.168/16), loopback, link-local, ULA. Cloud metadata endpoints always blocked (169.254.169.254, metadata.google.internal). DNS resolution checks resolved IPs. allowedDomains bypass all checks, blockedDomains always rejected. (3) Workspace Containment -- file tools sandboxed to workspace_dir. (4) Input Sanitization -- session IDs, tool results, content validated. (5) Output Truncation -- tool results capped at 64KB. Threat model: LLM prompt injection leading to tool execution. Allowlist recommended over denylist for LLM-controlled execution because denylists are inherently incomplete while allowlists fail closed. Validation flow: dangerous patterns -> mode-specific check -> execution. Config via tools.commandPolicy and tools.urlPolicy in JSON config, accepts both snake_case and camelCase."}],["entry_1771447609690_k3cq8c",{"id":"entry_1771447609690_k3cq8c","key":"project-metadata","namespace":"clawft-knowledge","content":"Project: clawft (Rust rewrite of nanobot). Binary: weft. Root: /home/aepod/dev/clawft/. Rust edition: 2024, MSRV: 1.93. 9 workspace crates: clawft-cli, clawft-core, clawft-types, clawft-llm, clawft-tools, clawft-services, clawft-channels, clawft-platform, clawft-macros. ~33,222 lines of Rust. ~7,072 lines of docs across 16 files. License: Apache 2.0. Status: Phase 3 complete through 3I. Channel plugins: Telegram, Slack, Discord (plus WhatsApp, Feishu, DingTalk, Email, QQ). Channel architecture: ChannelFactory builds Arc<dyn Channel>, PluginHost manages lifecycle (init, start, stop) and routes outbound messages. CancellationToken for graceful shutdown. Errors via ChannelError from clawft-types. RVF integration planned but not yet implemented (current vector store is brute-force in-memory). Feature flags: native-exec, delegate, vector-memory, rvf, rvf-agentdb, rvf-crypto, ruvllm, intelligent-routing, sona."}]]