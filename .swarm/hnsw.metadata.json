[["entry_1771266857024_z2qe3l",{"id":"entry_1771266857024_z2qe3l","key":"nanobot-architecture","namespace":"nanobot-analysis","content":"Nanobot is a ~9100-line Python AI agent framework. Core modules: agent/loop.py (476 lines, main processing engine), cli/commands.py (935 lines, typer CLI), config/schema.py (304 lines, pydantic config), channels/manager.py (227 lines), providers/litellm_provider.py (208 lines). Architecture: MessageBus (async queues) decouples channels from agent core. Agent loop: receive msg -> build context (system prompt + history + memory + skills) -> call LLM -> execute tool calls in loop -> send response. 9 channels: Telegram, WhatsApp, Discord, Slack, Feishu, DingTalk, QQ, Mochat, Email. 14 providers via LiteLLM + OpenAI Codex OAuth. 8 tool types: filesystem (read/write/edit/listdir), shell (exec), web (search/fetch), message, spawn, cron, MCP. Session management via JSONL files. Memory: MEMORY.md (long-term facts) + HISTORY.md (grep-searchable log). Skills: markdown SKILL.md files with YAML frontmatter. Cron: at/every/cron scheduling. Heartbeat: periodic HEARTBEAT.md check. Subagents: lightweight background agent instances. WhatsApp bridge: separate Node.js/TypeScript process using Baileys, communicates via WebSocket."}],["entry_1771266876113_ir8xpf",{"id":"entry_1771266876113_ir8xpf","key":"nanobot-dependencies","namespace":"nanobot-analysis","content":"Python deps: typer (CLI), litellm (multi-provider LLM), pydantic/pydantic-settings (config), websockets/websocket-client (WS), httpx (HTTP client), loguru (logging), readability-lxml (web content extraction), rich (terminal UI), croniter (cron expressions), prompt-toolkit (interactive input), mcp (MCP protocol client), json-repair (JSON fixing), slackify-markdown (Slack formatting). Channel-specific: python-telegram-bot, slack-sdk, qq-botpy, dingtalk-stream, lark-oapi, python-socketio, msgpack, socksio/python-socks. Bridge: @whiskeysockets/baileys (WhatsApp), ws (WebSocket server), pino (logging). Heavy deps that need Rust equivalents: litellm -> custom HTTP client, pydantic -> serde, httpx -> reqwest, asyncio -> tokio."}],["entry_1771266884068_s2gu2e",{"id":"entry_1771266884068_s2gu2e","key":"nanobot-module-map","namespace":"nanobot-analysis","content":"Module sizes (lines): cli/commands.py:935, channels/mochat.py:895, agent/loop.py:476, channels/email.py:403, channels/feishu.py:402, providers/registry.py:395, channels/telegram.py:390, cron/service.py:351, providers/openai_codex_provider.py:312, config/schema.py:304, channels/discord.py:261, agent/subagent.py:257, channels/dingtalk.py:245, agent/context.py:238, channels/slack.py:235, channels/manager.py:227, agent/skills.py:228, agent/tools/filesystem.py:211, providers/litellm_provider.py:208, session/manager.py:179, agent/tools/web.py:163, channels/whatsapp.py:148, agent/tools/shell.py:144, channels/qq.py:134, heartbeat/service.py:130, channels/base.py:127, agent/tools/cron.py:127, config/loader.py:106, agent/tools/base.py:102, agent/tools/message.py:86, bus/queue.py:81, agent/tools/mcp.py:80, utils/helpers.py:80, agent/tools/registry.py:73, providers/base.py:70, providers/transcription.py:65, agent/tools/spawn.py:65, cron/types.py:59, bus/events.py:37, agent/memory.py:30. Total: ~9134 lines Python + ~350 lines TypeScript bridge."}],["entry_1771266891365_bva75",{"id":"entry_1771266891365_bva75","key":"nanobot-data-flow","namespace":"nanobot-analysis","content":"Data flow: 1) Channels (telegram/slack/etc) receive messages -> create InboundMessage(channel, sender_id, chat_id, content, media, metadata) -> push to MessageBus.inbound queue. 2) AgentLoop.run() consumes from inbound queue -> _process_message() -> looks up/creates Session -> builds context (system prompt + bootstrap files + memory + skills + history + current msg) -> _run_agent_loop() iterates: call provider.chat() -> if tool_calls: execute tools, add results, continue; if content only: break. 3) Response saved to session -> OutboundMessage pushed to outbound queue. 4) ChannelManager._dispatch_outbound() routes messages to correct channel.send(). Key interfaces: Tool(ABC) with name/description/parameters/execute, LLMProvider(ABC) with chat/get_default_model, BaseChannel(ABC) with start/stop/send. Config: ~/.nanobot/config.json (camelCase JSON, converted to snake_case pydantic). Sessions: ~/.nanobot/sessions/*.jsonl. Workspace: ~/.nanobot/workspace/ with AGENTS.md, SOUL.md, USER.md, memory/, skills/."}],["entry_1771266898535_7q6q6y",{"id":"entry_1771266898535_7q6q6y","key":"nanobot-rust-rewrite-plan","namespace":"nanobot-analysis","content":"Rust/WASM Rewrite Plan - Target: lightweight, portable WASM binary for small devices. Core architecture stays the same: message bus + agent loop + channels + tools. Key decisions: 1) Use tokio for async runtime (not in WASM; use wasm-bindgen-futures for WASM target). 2) serde + serde_json for config/serialization. 3) reqwest (with wasm feature) for HTTP. 4) Custom LLM provider trait (no litellm equivalent in Rust). 5) Channel implementations as optional features (compile-time feature flags). 6) Tool system: trait-based with dynamic dispatch. 7) Config: keep JSON format, use serde for deserialization. 8) Sessions: keep JSONL format. 9) Memory: keep MEMORY.md/HISTORY.md file-based approach. 10) For WASM: no filesystem access directly, abstract behind trait. 11) CLI: clap for native, web API for WASM. 12) MCP: implement MCP client in Rust (mcp-rs or custom). Size target: <2MB WASM binary with wasm-opt."}]]