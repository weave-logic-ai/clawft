# UI Security Review -- ClawFT Web Dashboard + Live Canvas

> **Reviewer**: Security Architect Agent (SPARC)
> **Date**: 2026-02-23
> **Scope**: Web Dashboard, Live Canvas, REST API, WebSocket transport, Tauri desktop shell (phases S1.1 through S3.5)
> **Classification**: Internal -- Engineering Review
> **Status**: Initial Review (pre-implementation)

---

## Executive Summary

The UI workstream introduces a network-exposed HTTP/WebSocket API, a browser-rendered frontend with agent-generated dynamic content, and an optional native desktop shell via Tauri. This combination creates a fundamentally different attack surface from the existing CLI-only interaction model: the API is reachable over the network, the browser executes JavaScript in a shared origin, agent-generated Canvas commands can render interactive elements, and the Tauri IPC bridge exposes native capabilities to web content.

This review enumerates 12 threat categories, defines 12 security controls with implementation requirements, maps data flows across 4 security zones, establishes a permission matrix for all UI actions, and specifies 35 security exit criteria organized by deployment priority.

**Key findings:**
- XSS via agent-generated Canvas content (T1, T6) is the highest-impact risk: agents can push arbitrary element definitions through WebSocket, and any failure in schema validation allows JavaScript execution in the user's browser session
- Auth token lifecycle (T2, T8, T10) requires defense-in-depth: the `weft ui` one-time URL token, Bearer header transport, localStorage persistence, and WebSocket upgrade handshake each represent a distinct attack vector
- CORS misconfiguration (T3) can expose the entire API to cross-origin exploitation; the default must be restrictive with explicit allowlisting required for production
- The config editor API (T7) can expose provider API keys and security policy settings unless sensitive fields are masked server-side before transmission
- Tauri IPC (T12) bridges web content to native OS capabilities; an XSS vulnerability in the frontend becomes a native code execution vulnerability in the desktop shell

**Overall risk assessment: MANAGEABLE with controls specified below. P0 controls are mandatory before any network-accessible deployment.**

---

## 1. Threat Model

### Threat Enumeration

| ID | Threat | Category | Likelihood | Impact | Score | Description |
|----|--------|----------|------------|--------|-------|-------------|
| T1 | XSS via Agent-Generated Content | Injection | Medium | Critical | **9** | Agents produce chat messages, tool results, and Canvas commands that render in the browser. A compromised or misbehaving agent could inject `<script>` tags, `onerror` attributes, or `javascript:` URIs into text, markdown, or Canvas element properties. React's default escaping protects plain text, but markdown rendering (rehype), `dangerouslySetInnerHTML`, and Canvas element attributes are bypass vectors. Successful XSS grants full access to the user's auth token, session state, and API. |
| T2 | Auth Token Theft | Authentication | Medium | Critical | **9** | The auth token is generated by `weft ui`, passed as a URL parameter to the browser, then stored in localStorage. Attack vectors: (1) URL token visible in browser history, server logs, and Referer headers; (2) localStorage readable by any XSS payload in the same origin; (3) token transmitted in Authorization header interceptable without TLS; (4) token file at `~/.clawft/ui-token` readable by other local processes if permissions are wrong. Stolen token grants full API access. |
| T3 | CORS Misconfiguration | Access Control | Medium | High | **8** | If `cors_origins` is set to `*` or includes overly broad patterns, any website visited by the user can make authenticated cross-origin requests to the ClawFT API using the user's token (via fetch with credentials). This enables remote attackers to read agent data, modify configuration, or execute agent commands from a malicious page. The default of `localhost:5173` is safe for development but must be explicitly locked down for production. |
| T4 | WebSocket Flooding | Availability | High | Medium | **7** | An attacker (or a misbehaving client) can open many WebSocket connections or send a high volume of messages to exhaust server resources. Without per-connection rate limiting and connection caps, a single client can deny service to legitimate users. The Canvas WebSocket channel is especially vulnerable because it accepts bidirectional commands. |
| T5 | API Input Injection | Injection | Medium | High | **8** | REST endpoints accept path parameters (agent IDs, session keys), query parameters (search terms, filters), and JSON request bodies (config patches, memory writes). Without validation, attackers can inject: (1) path traversal sequences in session IDs; (2) oversized request bodies to exhaust memory; (3) malformed JSON to trigger parser errors that leak internal details; (4) SQL/NoSQL injection if future backends introduce database queries. The existing `validate_session_id` function covers session IDs but other parameters need equivalent validation. |
| T6 | Canvas Command Injection | Injection | Medium | Critical | **9** | The `render_ui` tool allows agents to push `CanvasCommand` objects (text, button, input, image, code, table, form, chart) to the frontend via WebSocket. If the Canvas renderer trusts element properties without schema validation, an agent could inject: (1) arbitrary `src` attributes pointing to attacker-controlled resources; (2) `onclick`/`onerror` handlers containing JavaScript; (3) form actions directing submissions to external URLs; (4) CSS injection via style properties for data exfiltration. This is distinct from T1 because it targets the structured Canvas protocol rather than free-text content. |
| T7 | Config Privilege Escalation | Authorization | Medium | Critical | **9** | The `PATCH /api/config` endpoint allows editing the running configuration. Without field-level access control, a user with a valid token could: (1) read provider API keys (if the GET endpoint returns unsanitized config); (2) modify `command_policy` to remove dangerous pattern checks; (3) change `url_policy` to allow SSRF; (4) alter `delegation` settings to redirect agent traffic to an attacker-controlled endpoint; (5) disable security controls by modifying `restrict_to_workspace` or `internal_only` flags. |
| T8 | Session Hijacking | Authentication | Medium | High | **8** | Attack vectors: (1) the one-time URL token from `weft ui` can be intercepted if the browser sends it to an analytics service via Referer header or if it appears in server access logs; (2) session fixation: if the server accepts a client-supplied token rather than generating one, an attacker can pre-set the token; (3) token replay: without expiry enforcement, a stolen token can be reused indefinitely; (4) concurrent sessions: without session binding (IP, user-agent), a token used from a different context is indistinguishable from legitimate use. |
| T9 | Path Traversal via Static Files | Information Disclosure | Low | High | **7** | The static file serving layer serves `ui/dist/` (or rust-embed assets). If the server does not canonicalize request paths, an attacker can request `GET /../../etc/passwd` or `GET /..%2F..%2Fetc/passwd` to read arbitrary files from the filesystem. Axum's `ServeDir` provides basic protection, but URL-encoded path segments, double encoding, and symlink following can bypass naive checks. |
| T10 | WebSocket Auth Bypass | Authentication | Medium | High | **8** | The WebSocket upgrade request must validate the Bearer token before completing the handshake. If token validation only happens on the initial HTTP request but not on the WebSocket upgrade path, or if the upgrade handler skips auth for the `/ws` and `/ws/canvas` endpoints, an unauthenticated client can establish a persistent connection and receive all real-time events (agent messages, Canvas commands, system status). |
| T11 | Multi-User Data Leakage | Information Disclosure | Low | Critical | **8** | When Tailscale auth is enabled (S3.5), multiple users share the same server. Without per-user isolation: (1) user A can see user B's sessions via `GET /api/sessions`; (2) WebSocket broadcast events leak cross-user data; (3) memory search returns entries from all namespaces; (4) config changes by one user affect all users. The `X-Tailscale-User` header is trust-on-first-use and can be forged if the server is accessible outside the Tailscale network. |
| T12 | Tauri IPC Exploitation | Privilege Escalation | Low | Critical | **8** | The Tauri desktop shell (S3.4) exposes IPC commands to the web content: auto-start gateway, system tray control, global hotkeys, and native notifications. An XSS vulnerability in the frontend becomes a native code execution vector because the attacker's JavaScript runs in the Tauri WebView with access to the IPC bridge. Tauri's command allowlist mitigates this, but misconfiguration (allowing `shell:execute` or filesystem commands) escalates browser-level XSS to full system compromise. |

### Risk Matrix

```
Impact ->     Low        Medium      High       Critical
Likelihood
  High                   T4(7)
  Medium                            T3(8) T5(8) T1(9) T2(9) T6(9) T7(9)
                                    T8(8) T10(8)
  Low                               T9(7)       T11(8) T12(8)
```

### Threat Severity Classification

- **Critical (Score 9-10)**: T1, T2, T6, T7 -- Must be addressed before any network-accessible deployment
- **High (Score 7-8)**: T3, T4, T5, T8, T9, T10, T11, T12 -- Must be addressed before production deployment
- **Medium (Score 4-6)**: None identified
- **Low (Score 1-3)**: None identified

---

## 2. Security Controls

### SC-1: Content Security Policy (mitigates T1, T6, T12)

| Control | Implementation | Priority |
|---------|---------------|----------|
| CSP header on all HTML responses | `Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; connect-src 'self' ws://localhost:* wss://localhost:*; frame-ancestors 'none'; base-uri 'self'; form-action 'self'` | P0 |
| Block inline scripts | `script-src 'self'` with no `'unsafe-inline'` or `'unsafe-eval'`. Vite build output uses external script files, not inline `<script>` blocks. Verify with `vite-plugin-csp` or post-build CSP audit. | P0 |
| Block eval | No `'unsafe-eval'` in `script-src`. This blocks `eval()`, `new Function()`, `setTimeout(string)`, and all dynamic code generation. Verify that no dependencies (Monaco, recharts) require eval; if so, use worker-based alternatives. | P0 |
| Connect-src allowlist | `connect-src 'self'` plus the configured API URL and WebSocket URL. The frontend's `VITE_API_URL` value must be included. Wildcard `*` is prohibited. | P0 |
| Frame-ancestors none | `frame-ancestors 'none'` prevents clickjacking by disallowing the dashboard from being embedded in iframes on attacker-controlled pages. | P1 |
| Report-uri (monitoring) | `report-uri /api/csp-report` endpoint that logs CSP violations. Used for detecting XSS attempts and policy misconfiguration. Log but do not block (report-only mode) during initial rollout. | P2 |

### SC-2: Token Authentication (mitigates T2, T8, T10)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Token generation | `weft ui` generates a cryptographically random token (32 bytes, base64url-encoded) using `rand::rngs::OsRng`. Token is stored in `~/.clawft/ui-token` with `0600` file permissions. Token has a configurable TTL (default: 24 hours), encoded as a signed JWT or as a server-side expiry record. | P0 |
| URL token consumed on first use | The `?token=` parameter in the browser URL is a single-use bootstrap token. On first `POST /api/auth/token` with this value, the server returns a session Bearer token and invalidates the URL token. The URL token cannot be reused. | P0 |
| localStorage storage | The session Bearer token is stored in `localStorage` under a namespaced key (`clawft:auth:token`). Tokens are never stored in cookies (eliminates CSRF). The `use-auth` hook clears the token from `window.location` immediately after extraction to prevent Referer leakage. | P0 |
| Bearer header transport | All API requests attach `Authorization: Bearer <token>`. Tokens are never sent as query parameters (except the one-time bootstrap). Tokens are never included in WebSocket messages after the initial upgrade handshake. | P0 |
| Token expiry enforcement | Server rejects expired tokens with `401 Unauthorized`. Response includes `WWW-Authenticate: Bearer error="invalid_token"` but no token details. The frontend detects 401 and redirects to re-authentication flow. | P0 |
| Token rotation | Optional: issue short-lived access tokens (15 min) with a longer-lived refresh token (24 hours). The refresh token is stored in `localStorage`; the access token is held in memory only. This limits the window of exposure for a stolen access token. | P2 |

### SC-3: CORS Configuration (mitigates T3)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Explicit origin allowlist | `tower-http::cors::CorsLayer` configured with `AllowOrigin::list()` from `GatewayConfig.cors_origins`. No wildcard `*`. Default: `["http://localhost:5173"]` for Vite dev server. | P0 |
| Credentials restricted | `Access-Control-Allow-Credentials: true` only for origins in the allowlist. If `Access-Control-Allow-Origin` is `*`, credentials must be `false` (browser enforces this, but the server must not send mixed signals). | P0 |
| Preflight caching | `Access-Control-Max-Age: 3600` to reduce preflight request volume. Methods: `GET, POST, PATCH, DELETE, OPTIONS`. Headers: `Authorization, Content-Type`. | P1 |
| Production warning | If `cors_origins` contains `localhost` and the server binds to a non-loopback address (not `127.0.0.1`), emit a startup warning: "CORS allows localhost origins but server is network-accessible. Configure explicit production origins." | P1 |

### SC-4: WebSocket Security (mitigates T4, T10)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Auth on upgrade | The WebSocket upgrade handler (`/ws`, `/ws/canvas`) extracts the Bearer token from the `Authorization` header or the `Sec-WebSocket-Protocol` header (for browsers that cannot set custom headers on WebSocket). Token is validated before the upgrade completes. Reject with `403 Forbidden` if invalid. | P0 |
| Origin validation | Check the `Origin` header on WebSocket upgrade requests against `GatewayConfig.cors_origins`. Reject upgrades from unexpected origins. | P0 |
| Per-connection rate limiting | Maximum 100 messages per second per connection. Exceeding the limit triggers a warning frame, then disconnection after 3 consecutive violations. Implement with a token bucket per connection. | P0 |
| Connection limit | Maximum 50 concurrent WebSocket connections per token. Reject new connections with `429 Too Many Requests` when the limit is reached. | P1 |
| Heartbeat and dead connection cleanup | Server sends ping frames every 30 seconds. If no pong is received within 10 seconds, the connection is terminated. This prevents resource exhaustion from abandoned connections. | P1 |
| Message size limit | Maximum 64 KB per WebSocket message. Messages exceeding this are rejected and the connection is closed with status 1009 (Message Too Big). | P1 |

### SC-5: Input Validation (mitigates T5)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Path parameter validation | All UUID path parameters (`/api/agents/:id`, `/api/sessions/:id`) validated against UUID v4 format regex. Non-UUID name parameters validated against `^[a-zA-Z0-9_-]{1,128}$`. Reject with `400 Bad Request`. | P0 |
| Request body size limit | `tower-http::limit::RequestBodyLimitLayer` with 1 MB default for API endpoints, 10 MB for file upload endpoints. Reject with `413 Payload Too Large`. | P0 |
| JSON schema validation | All `POST` and `PATCH` request bodies validated against expected JSON schemas. Unknown fields rejected (strict mode). Nested object depth limited to 10 levels. | P0 |
| Query parameter sanitization | Search queries, filter values, and pagination parameters validated for type, length (max 500 chars), and format. Reject SQL-like injection patterns (`'; DROP`, `UNION SELECT`). | P1 |
| Content-Type enforcement | API endpoints only accept `application/json`. Reject other content types with `415 Unsupported Media Type`. | P1 |

### SC-6: Canvas Sanitization (mitigates T1, T6)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Schema validation | Every `CanvasCommand` received via WebSocket is validated against a strict TypeScript/Zod schema before rendering. The schema defines the exact shape of each element type (text, button, input, image, code, table, form, chart). Unknown element types are rejected. Unknown properties within elements are stripped. | P0 |
| Element type allowlist | Only the defined element types are renderable: `text`, `button`, `input`, `image`, `code`, `table`, `form`, `chart`. No `html`, `iframe`, `script`, `embed`, `object`, or `link` element types. | P0 |
| Attribute sanitization | Element properties are type-checked: `src` must be a valid URL (no `javascript:`, `data:text/html`, or `vbscript:` schemes); `href` must be `https://` or relative; `style` is parsed and only safe CSS properties are allowed (no `url()`, `expression()`, `behavior`); event handlers (`onclick`, `onerror`, `onload`) are stripped entirely. | P0 |
| Text content escaping | All text content within Canvas elements is rendered through React's JSX escaping (no `dangerouslySetInnerHTML`). Markdown content uses `rehype-sanitize` with a strict allowlist (no raw HTML tags, no `javascript:` links). | P0 |
| Image URL validation | Canvas `image` elements validate `src` against: (1) same-origin check; (2) HTTPS-only for external URLs; (3) no `data:text/html` URIs; (4) optional allowlist of permitted image domains. | P1 |
| Form action restriction | Canvas `form` elements have their `action` attribute stripped. Form submissions are routed exclusively through the WebSocket interaction protocol back to the agent, never to external URLs. | P0 |

### SC-7: Config Protection (mitigates T7)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Sensitive field masking | `GET /api/config` response replaces all `SecretString` fields (API keys, tokens) with `"[REDACTED]"`. The existing `SecretString` serialization (emits `""`) provides the foundation; the API layer replaces empty strings with the redaction marker for clarity. | P0 |
| Security field write protection | `PATCH /api/config` rejects modifications to security-critical fields: `providers.*.api_key`, `channels.*.token`, `tools.command_policy`, `tools.url_policy`, `tools.restrict_to_workspace`, `tools.mcp_servers.*.internal_only`. These fields can only be changed via the config file or CLI. | P0 |
| Audit logging | All config changes via the API are logged with: timestamp, user identity (token hash or Tailscale user), field path changed, old value (redacted if sensitive), new value (redacted if sensitive). Log format: `[config] PATCH by user=<hash> field=agents.defaults.model old="gpt-4" new="claude-opus-4-5"`. | P0 |
| Config validation before apply | `PATCH /api/config` validates the merged config against the full schema before applying. If validation fails, return `422 Unprocessable Entity` with specific error details. The running config is never left in an invalid state. | P1 |
| Confirmation for destructive changes | Changes to `agents.defaults.model`, `delegation`, or `routing` require a confirmation header: `X-Confirm: true`. Without this header, the server returns `409 Conflict` with a description of the pending change's impact. | P1 |

### SC-8: Session Management (mitigates T2, T8, T11)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Token lifecycle | Tokens progress through states: `active` -> `expired` -> `revoked`. Expired tokens are rejected. Revoked tokens (via `DELETE /api/auth/token`) are rejected immediately. Token state is checked on every API request. | P0 |
| Single-use URL tokens | The bootstrap `?token=` parameter is a one-time-use nonce. It is stored server-side with a `consumed` flag. After first use, subsequent requests with the same URL token return `401`. The nonce expires after 5 minutes even if unused. | P0 |
| Token binding (optional) | Bind tokens to the client's IP address and User-Agent at creation time. If a request arrives from a different IP or User-Agent, log a warning and optionally reject (configurable via `gateway.strict_token_binding`). | P2 |
| URL sanitization | The frontend `use-auth` hook immediately strips the `?token=` parameter from `window.location` using `history.replaceState()` after extracting the token. This prevents the token from appearing in Referer headers, browser history, or analytics tools. | P0 |

### SC-9: Static File Security (mitigates T9)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Path canonicalization | Use `tower-http::services::ServeDir` which canonicalizes paths and rejects `..` traversal. Verify that percent-encoded sequences (`%2F`, `%2E`) are decoded before canonicalization, not after. | P0 |
| No directory listing | `ServeDir` is configured without `append_index_of(true)` directory listing. Requests to directories return the SPA `index.html` (for client-side routing) or `404`. | P0 |
| Symlink following disabled | If using filesystem-based serving, symlinks are not followed (use `ServeDir::with_dereference(false)` if available, or verify that the serving root contains no symlinks at startup). With `rust-embed`, this is not a concern since files are compiled into the binary. | P1 |
| Security headers on static files | Static file responses include: `X-Content-Type-Options: nosniff`, `X-Frame-Options: DENY`, `Referrer-Policy: strict-origin-when-cross-origin`, `Permissions-Policy: microphone=(), camera=(), geolocation=()`. | P0 |

### SC-10: Tauri IPC Security (mitigates T12)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Command allowlist | Tauri `tauri.conf.json` defines an explicit allowlist of IPC commands. Only the minimum required commands are permitted: `window:show`, `window:hide`, `notification:send`, `tray:set_icon`. Shell execution (`shell:execute`, `shell:open`) is NOT included. | P0 |
| Origin validation | Tauri WebView only loads content from the built `ui/dist/` (local files) or the configured local API URL. External URLs are blocked from accessing IPC commands via the `dangerous_remote_domain_ipc_access` setting (must remain empty/false). | P0 |
| No shell access | The Tauri `shell` scope is disabled entirely. The gateway process (`weft gateway`) is launched via Tauri's sidecar mechanism with a fixed command, not through shell execution from web content. | P0 |
| CSP in Tauri | The Tauri security configuration sets its own CSP: `default-src 'self'; script-src 'self'`. This provides defense-in-depth even if the web server CSP is bypassed. | P1 |

### SC-11: Rate Limiting (mitigates T4, T5)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Per-token API rate limit | Token bucket: 100 requests per minute per auth token. Exceeded requests return `429 Too Many Requests` with `Retry-After` header. Implemented via `tower::limit::RateLimitLayer` or a custom middleware with `governor` crate. | P0 |
| Per-IP rate limit | 200 requests per minute per IP address (covers unauthenticated endpoints like `/api/auth/token` and static files). Prevents brute-force token guessing. | P0 |
| Auth endpoint rate limit | `POST /api/auth/token` limited to 5 requests per minute per IP. Prevents brute-force attacks on the one-time URL token exchange. | P0 |
| Graduated response | First violation: `429` response. 10 violations in 1 minute: 60-second IP block. 100 violations in 10 minutes: 10-minute IP block. Configurable thresholds. | P2 |

### SC-12: Error Handling (mitigates T5, T9)

| Control | Implementation | Priority |
|---------|---------------|----------|
| Generic error responses | API error responses use a standard format: `{"error": {"code": "CATEGORY", "message": "Human-readable description"}}`. No stack traces, file paths, SQL queries, or internal details are included. | P0 |
| Error code mapping | Map internal errors to safe external codes: `ClawftError::SecurityViolation` -> `403 FORBIDDEN`; `serde_json::Error` -> `400 BAD_REQUEST`; `tokio::time::error::Elapsed` -> `504 GATEWAY_TIMEOUT`; all others -> `500 INTERNAL_ERROR` with generic message. | P0 |
| Panic handler | Axum server uses `tower-http::catch-panic::CatchPanicLayer` to convert panics into `500 Internal Server Error` responses instead of crashing the server or leaking panic messages. | P0 |
| Error logging | Internal error details (stack traces, context) are logged server-side at `error` level for debugging. Client-facing responses contain only the safe error code and message. | P1 |

---

## 3. Data Flow Diagram

```text
                         UI DATA FLOW -- SECURITY BOUNDARIES
                         ====================================

  +------------------------------------------------------------------------+
  |  ZONE 1: BROWSER (untrusted)                                           |
  |                                                                        |
  |  +-------------------+    +-------------------+    +-----------------+ |
  |  | React Frontend    |    | localStorage      |    | Service Worker  | |
  |  | - Dashboard views |    | - auth token      |    | - PWA cache     | |
  |  | - WebChat         |    | - theme prefs     |    | - offline shell | |
  |  | - Canvas Renderer |    | - NO secrets      |    |                 | |
  |  | - Config Editor   |    |                   |    |                 | |
  |  +--------+----------+    +-------------------+    +-----------------+ |
  |           |                                                            |
  |   [SC-1: CSP restricts script sources, blocks eval]                    |
  |   [SC-6: Canvas commands schema-validated before render]               |
  |   [SC-8: URL token stripped from location immediately]                 |
  |           |                                                            |
  +-----------+------------------------------------------------------------+
              |
              | Authorization: Bearer <token>
              | Content-Type: application/json
              | Origin: http://localhost:5173
              |
  +-----------v------------------------------------------------------------+
  |  ZONE 2: NETWORK (untrusted transport)                                 |
  |                                                                        |
  |   HTTP/1.1 + TLS 1.2+  |  WebSocket (wss://) + TLS                    |
  |                                                                        |
  |   [SC-3: CORS rejects unauthorized origins]                            |
  |   [SC-11: Per-IP rate limiting applied before auth]                    |
  |                                                                        |
  +-----------+------------------------------------------------------------+
              |
              | Validated origin, within rate limit
              |
  +-----------v------------------------------------------------------------+
  |  ZONE 3: API GATEWAY (trusted boundary)                                |
  |                                                                        |
  |  +-------------------------------------------------------------------+ |
  |  | Axum Middleware Stack (tower layers, applied in order)             | |
  |  |                                                                   | |
  |  |  1. CatchPanic          [SC-12: convert panics to 500]            | |
  |  |  2. RequestBodyLimit     [SC-5: 1MB / 10MB limits]                | |
  |  |  3. Cors                 [SC-3: origin allowlist]                 | |
  |  |  4. RateLimit            [SC-11: per-token bucket]                | |
  |  |  5. BearerAuth           [SC-2: token validation + expiry]        | |
  |  |  6. SecurityHeaders      [SC-9: X-Content-Type-Options, etc.]     | |
  |  |                                                                   | |
  |  +----+--------------------------------------------------------------+ |
  |       |                                                                |
  |       v                                                                |
  |  +----+----------------------------------------------+                 |
  |  | REST Handlers                                     |                 |
  |  | GET /api/agents      -> agent list                |                 |
  |  | POST /api/agents     -> [SC-5: validate body]     |                 |
  |  | GET /api/config      -> [SC-7: mask secrets]      |                 |
  |  | PATCH /api/config    -> [SC-7: write-protect]     |                 |
  |  | GET /api/sessions    -> [SC-8: user-scoped]       |                 |
  |  | POST /api/auth/token -> [SC-11: 5/min rate]       |                 |
  |  +---------------------------------------------------+                 |
  |       |                                                                |
  |  +----+----------------------------------------------+                 |
  |  | WebSocket Handlers                                |                 |
  |  | /ws         -> [SC-4: auth on upgrade]            |                 |
  |  |                [SC-4: rate limit messages]         |                 |
  |  |                [SC-4: origin check]                |                 |
  |  | /ws/canvas  -> [SC-4: auth + rate limit]          |                 |
  |  |                [SC-6: validate outbound commands]  |                 |
  |  +---------------------------------------------------+                 |
  |       |                                                                |
  |  +----+----------------------------------------------+                 |
  |  | Static File Server                                |                 |
  |  | /* (SPA fallback) -> [SC-9: path canonicalization] |                 |
  |  |                      [SC-9: no directory listing]  |                 |
  |  |                      [SC-1: CSP headers]           |                 |
  |  +---------------------------------------------------+                 |
  |                                                                        |
  +-----------+------------------------------------------------------------+
              |
              | Validated request, authenticated user
              |
  +-----------v------------------------------------------------------------+
  |  ZONE 4: CORE (trusted)                                                |
  |                                                                        |
  |  +-------------------------------------------------------------------+ |
  |  | Agent Loop (loop_core.rs)                                         | |
  |  | - Processes commands from REST/WS handlers                        | |
  |  | - Executes tools (render_ui, read_file, exec, etc.)               | |
  |  | - Generates responses routed to WebSocket subscribers             | |
  |  +-------------------------------------------------------------------+ |
  |                                                                        |
  |  +-------------------------------------------------------------------+ |
  |  | Tool Registry (registry.rs)                                       | |
  |  | - render_ui tool pushes CanvasCommands to WS handler              | |
  |  | - Tools execute within sandbox (CommandPolicy, UrlPolicy)         | |
  |  +-------------------------------------------------------------------+ |
  |                                                                        |
  |  +-------------------------------------------------------------------+ |
  |  | Session / Memory Storage                                          | |
  |  | - Session data isolated per user (when multi-user enabled)        | |
  |  | - Memory writes scoped to authenticated user's namespace          | |
  |  | - Config changes audited with user identity                       | |
  |  +-------------------------------------------------------------------+ |
  |                                                                        |
  +------------------------------------------------------------------------+

  LEGEND:
  ----- = data flow
  +---+ = processing stage / component
  [SC-N] = security control applied at this point
  ZONE 1 = browser (untrusted, attacker-controlled JS possible via XSS)
  ZONE 2 = network transport (untrusted, subject to interception)
  ZONE 3 = API gateway (trusted boundary, all validation happens here)
  ZONE 4 = core engine (trusted, assumes input pre-validated by Zone 3)
```

### Critical Security Boundaries

1. **Zone 1 -> Zone 2 boundary**: The browser sends the auth token via the `Authorization` header. The token must never appear in URLs (after initial bootstrap), cookies, or request bodies. CSP prevents exfiltration of the token via injected scripts.

2. **Zone 2 -> Zone 3 boundary**: CORS, rate limiting, and TLS enforcement happen here. This is the first line of defense against cross-origin attacks and flooding.

3. **Zone 3 -> Zone 4 boundary**: All input validation, authentication, and authorization happens in Zone 3 middleware. Zone 4 (core) trusts that inputs are pre-validated. If Zone 3 validation is bypassed, Zone 4 has no secondary defenses for API-originated input.

4. **Zone 4 -> Zone 1 (outbound)**: Agent-generated content flows from the core through WebSocket to the browser. Canvas commands must be schema-validated in Zone 3 (outbound) before reaching Zone 1, and re-validated by the frontend's Canvas renderer as defense-in-depth.

---

## 4. Permission Matrix

| UI Action | Required Permission | Token Type | Confirmation Required | Notes |
|-----------|-------------------|------------|----------------------|-------|
| View dashboard | Read | Any valid token | No | Agent counts, system health, channel status |
| View agent list | Read | Any valid token | No | List with status badges |
| Start/stop agent | Admin | Admin token | No | State change action; audit logged |
| Create/delete agent | Admin | Admin token | Yes (`X-Confirm`) | Destructive action |
| View WebChat messages | Read | Any valid token | No | Scoped to user's sessions in multi-user mode |
| Send chat message | Write | Write or admin token | No | Creates new message in session |
| View sessions | Read | Any valid token | No | Scoped to user's sessions in multi-user mode |
| Delete session | Write | Write or admin token | Yes (`X-Confirm`) | Destructive, audit logged |
| Export session | Read | Any valid token | No | Downloads session data as JSON |
| View tool registry | Read | Any valid token | No | Tool names and schemas |
| View config | Read | Any valid token | No | Sensitive fields masked (SC-7) |
| Edit config | Admin | Admin token | Yes (`X-Confirm` for critical fields) | Security fields write-protected (SC-7) |
| Install skill | Admin | Admin token | Yes (user confirmation dialog) | Downloads and loads external code |
| Uninstall skill | Admin | Admin token | Yes (`X-Confirm`) | Removes skill and associated tools |
| Search memory | Read | Any valid token | No | Scoped to user's namespace in multi-user mode |
| Write memory | Write | Write or admin token | No | Scoped to user's namespace |
| Delete memory | Write | Write or admin token | Yes (`X-Confirm`) | Destructive, audit logged |
| Canvas interaction | Read-Write | Session-scoped token | No | Button clicks, form submits routed to agent |
| WebSocket subscribe | Read | Any valid token | No | Auth validated on upgrade handshake (SC-4) |
| Create cron job | Admin | Admin token | No | Schedules recurring agent execution |
| Delete cron job | Admin | Admin token | Yes (`X-Confirm`) | Removes scheduled execution |
| View delegation rules | Read | Any valid token | No | Routing and delegation config |
| Edit delegation rules | Admin | Admin token | Yes (`X-Confirm`) | Changes agent routing behavior |

### Token Types

| Type | Capabilities | Default TTL | Generation |
|------|-------------|-------------|------------|
| Read-only | View all data (masked secrets), WebSocket subscribe | 24 hours | `weft ui --read-only` |
| Write | Read + create/modify sessions, memory, chat | 24 hours | `weft ui` |
| Admin | Write + agent management, config editing, skill install | 24 hours | `weft ui --admin` |

---

## 5. Security Exit Criteria

### P0 -- Must pass before any network-accessible deployment (16 items)

- [ ] CSP header set on all HTML responses with `script-src 'self'` (no `unsafe-inline`, no `unsafe-eval`)
- [ ] Bearer token auth middleware rejects unauthenticated requests with 401 on all `/api/*` routes (except `/api/auth/token`)
- [ ] One-time URL token (`?token=`) is consumed on first use and cannot be replayed
- [ ] Frontend strips `?token=` from `window.location` immediately after extraction via `history.replaceState()`
- [ ] Token stored in `localStorage` under namespaced key; never in cookies
- [ ] WebSocket upgrade handler validates Bearer token before completing handshake (both `/ws` and `/ws/canvas`)
- [ ] CORS middleware uses explicit origin allowlist; wildcard `*` is never used
- [ ] Canvas commands validated against strict Zod schema before rendering; unknown element types rejected
- [ ] No `dangerouslySetInnerHTML` used on agent-generated content (chat messages, tool results, Canvas text)
- [ ] Markdown rendering uses `rehype-sanitize` with strict HTML tag allowlist
- [ ] Canvas element attributes sanitized: no `javascript:` URIs, no event handler attributes, no `data:text/html` sources
- [ ] `GET /api/config` masks all `SecretString` fields with `[REDACTED]`
- [ ] `PATCH /api/config` rejects writes to security-critical fields (API keys, command policy, URL policy)
- [ ] Request body size limited to 1 MB (API) / 10 MB (file upload) via middleware
- [ ] API error responses contain no stack traces, file paths, or internal details
- [ ] Axum server uses `CatchPanicLayer` to convert panics to 500 responses

### P1 -- Must pass before production deployment (12 items)

- [ ] Per-token rate limiting enforced: 100 requests/min per token
- [ ] Per-IP rate limiting enforced: 200 requests/min per IP
- [ ] Auth endpoint rate limiting: 5 requests/min per IP on `POST /api/auth/token`
- [ ] WebSocket per-connection rate limit: 100 messages/sec; violations trigger disconnect
- [ ] WebSocket heartbeat (30s ping) detects and terminates dead connections
- [ ] WebSocket message size capped at 64 KB
- [ ] Static file serving rejects path traversal (verify with `../`, `%2e%2e/`, double-encoded sequences)
- [ ] Static file responses include `X-Content-Type-Options: nosniff` and `X-Frame-Options: DENY`
- [ ] Config change audit logging records timestamp, user identity, field path, and redacted values
- [ ] Token expiry enforced server-side; expired tokens return 401
- [ ] Canvas form elements have `action` attribute stripped; submissions route through WebSocket only
- [ ] `X-Tailscale-User` header auth verifies source IP is the Tailscale proxy (not forgeable by clients)

### P2 -- Recommended security enhancements (7 items)

- [ ] CSP `report-uri` endpoint logs violations for XSS detection
- [ ] Token rotation: short-lived access tokens (15 min) with refresh token (24 hours)
- [ ] Token binding to client IP and User-Agent (configurable `gateway.strict_token_binding`)
- [ ] Graduated rate limit response: IP blocking after repeated violations
- [ ] Canvas image `src` validated against optional domain allowlist
- [ ] Tauri IPC command allowlist restricts to `window:show`, `window:hide`, `notification:send`, `tray:set_icon` only
- [ ] Tauri security config sets its own CSP independent of the web server CSP

---

## 6. Recommendations

Ranked by priority (highest first):

### R1. Canvas sanitization is the single most critical control (P0, implement in S2.1)

The Canvas renderer is where agent-generated structured data meets browser rendering. Unlike free-text chat (protected by React's JSX escaping), Canvas commands define element types, attributes, styles, and interaction handlers. A single bypass in schema validation allows arbitrary JavaScript execution in the user's session.

**Implementation guidance:**
- Define the `CanvasCommand` Zod schema in `ui/src/lib/canvas-schema.ts` as the single source of truth
- Validate every inbound Canvas command in the WebSocket message handler before passing to `CanvasRenderer`
- Use a strict allowlist for element types (no `html`, `iframe`, `script`)
- Strip all event handler attributes (`onClick`, `onError`, `onLoad`) from element definitions
- Validate URL attributes (`src`, `href`) against a protocol allowlist: `https:`, `http:` (localhost only), and relative paths
- Write dedicated fuzz tests for the Canvas sanitizer with known XSS payloads from the OWASP XSS Filter Evasion Cheat Sheet

### R2. Auth token lifecycle must be airtight before any network exposure (P0, implement in S1.1)

The `weft ui` authentication flow has four distinct token states (URL nonce, session bearer, localStorage persistence, WebSocket handshake) and each is a separate attack surface. Design the token system as a state machine:

```
URL nonce (5 min TTL, single-use)
  -> POST /api/auth/token (consumes nonce)
  -> Session bearer (24h TTL, in-memory + localStorage)
    -> Authorization header (every request)
    -> WebSocket upgrade (one-time per connection)
    -> Expired / Revoked (terminal states)
```

Verify each state transition with integration tests. Ensure the URL nonce is consumed atomically (race condition: two tabs opening simultaneously must not both succeed).

### R3. CORS default must be restrictive with loud warnings for misconfiguration (P0, implement in S1.1)

CORS misconfiguration is a silent vulnerability; it does not produce errors during normal development. The default `cors_origins: ["http://localhost:5173"]` is correct for development, but production deployments require explicit configuration.

**Implementation guidance:**
- If `cors_origins` is empty, default to `["http://localhost:5173"]` and log a warning
- If the server binds to a non-loopback address and `cors_origins` contains `localhost`, log a prominent warning at startup
- Never allow `*` as an origin; reject it at config validation time with a clear error message
- Document the CORS configuration requirement prominently in the deployment guide

### R4. Config editor must be read-only for secrets and write-protected for security fields (P0, implement in S2.4)

The config editor provides a convenient UI for modifying the running configuration, but it also provides a convenient attack surface for privilege escalation. The existing `SecretString` type serializes to empty strings, which prevents accidental exposure, but the API layer must go further:

**Implementation guidance:**
- `GET /api/config` replaces all `SecretString` fields with `"[REDACTED]"` (not empty string, which is ambiguous)
- `PATCH /api/config` maintains a hardcoded denylist of field paths that cannot be modified via the API
- The denylist includes: all `*.api_key` fields, all `*.token` fields, `tools.command_policy`, `tools.url_policy`, `tools.restrict_to_workspace`, `routing.level`
- Config changes are validated against the full schema before applying (never leave the config in a broken state)
- All config changes are audit-logged with the authenticated user's identity

### R5. WebSocket auth must not be skippable (P0, implement in S1.1)

The WebSocket upgrade path is a common auth bypass vector because browsers cannot set custom `Authorization` headers on the `new WebSocket()` constructor. Two patterns are used in practice:

**Option A (recommended):** Send the token as the first message after the WebSocket connection is established. The server buffers messages until the auth message is received and validated. If auth is not received within 5 seconds, the connection is terminated.

**Option B:** Use the `Sec-WebSocket-Protocol` header to transmit the token (the client sets `new WebSocket(url, [token])`; the server validates the protocol header and echoes it back). This is a widely-used pattern but leaks the token in network logs.

Choose one approach and implement it consistently for both `/ws` and `/ws/canvas`.

### R6. Tauri IPC must be locked down before the desktop shell ships (P0 for Tauri, implement in S3.4)

Tauri's default security posture is strong, but misconfiguration turns any browser-level XSS into native code execution. The key risk is that Tauri's `allowlist` is opt-in: features must be explicitly enabled, and the defaults are restrictive. However, developers may enable `shell:execute` or `fs:read` during development and forget to remove them.

**Implementation guidance:**
- The `tauri.conf.json` security configuration must be reviewed as part of the build pipeline
- Add a CI check that verifies the Tauri allowlist does not include `shell:execute`, `shell:open`, `fs:*`, `process:*`
- The `dangerous_remote_domain_ipc_access` setting must be empty
- Document the Tauri security model in the contribution guide so developers understand the risk of expanding the allowlist

### R7. Multi-user isolation requires a dedicated security review before enabling (P1, implement in S3.5)

The multi-user Tailscale auth mode introduces cross-user data isolation requirements that affect every API endpoint. This is a separate security domain from single-user auth. Before enabling multi-user mode:

- Audit every API handler for user-scoping (does `GET /api/sessions` filter by user?)
- Audit every WebSocket subscription for user-scoping (does the broadcast channel filter by user?)
- Verify that `X-Tailscale-User` headers cannot be forged by clients (check source IP against Tailscale proxy)
- Add integration tests that verify user A cannot access user B's data

### R8. Implement a security test suite alongside the UI test suite (P1, continuous)

Security controls are only effective if they are tested. Create a dedicated `ui/tests/security/` directory with:
- CSP header verification tests (assert `script-src 'self'` on all HTML responses)
- CORS tests (assert rejected requests from unauthorized origins)
- Auth tests (assert 401 on expired tokens, consumed URL nonces, missing headers)
- XSS payload tests for Canvas renderer (OWASP XSS payloads injected via mock Canvas commands)
- Path traversal tests for static file serving (assert 404 on `../` sequences)
- Rate limiting tests (assert 429 after exceeding limits)

---

## Appendix A: Threat-to-Control Mapping

| Threat | Primary Controls | Secondary Controls |
|--------|-----------------|-------------------|
| T1 (XSS via Agent Content) | SC-1 (CSP), SC-6 (Canvas Sanitization) | SC-12 (Error Handling) |
| T2 (Auth Token Theft) | SC-2 (Token Auth), SC-8 (Session Mgmt) | SC-1 (CSP) |
| T3 (CORS Misconfiguration) | SC-3 (CORS Config) | SC-11 (Rate Limiting) |
| T4 (WebSocket Flooding) | SC-4 (WebSocket Security), SC-11 (Rate Limiting) | -- |
| T5 (API Input Injection) | SC-5 (Input Validation), SC-12 (Error Handling) | SC-11 (Rate Limiting) |
| T6 (Canvas Command Injection) | SC-6 (Canvas Sanitization), SC-1 (CSP) | SC-4 (WebSocket Security) |
| T7 (Config Privilege Escalation) | SC-7 (Config Protection) | SC-2 (Token Auth), SC-5 (Input Validation) |
| T8 (Session Hijacking) | SC-8 (Session Mgmt), SC-2 (Token Auth) | SC-11 (Rate Limiting) |
| T9 (Path Traversal) | SC-9 (Static File Security) | SC-12 (Error Handling) |
| T10 (WebSocket Auth Bypass) | SC-4 (WebSocket Security), SC-2 (Token Auth) | -- |
| T11 (Multi-User Data Leakage) | SC-8 (Session Mgmt) | SC-7 (Config Protection) |
| T12 (Tauri IPC Exploitation) | SC-10 (Tauri IPC Security), SC-1 (CSP) | SC-6 (Canvas Sanitization) |

## Appendix B: Comparison with Existing Security Infrastructure

The UI security model extends the existing ClawFT security infrastructure:

| Existing Security Feature | UI Equivalent |
|--------------------------|---------------|
| `CommandPolicy` (allowlist/denylist) | SC-7: Config PATCH denylist for security fields |
| `UrlPolicy` (SSRF protection) | SC-6: Canvas image/link URL validation |
| `SecretString` (redaction in logs/serialization) | SC-7: API config response masking |
| `validate_session_id()` (path traversal) | SC-5: Path parameter validation on all endpoints |
| `sanitize_content()` (control char stripping) | SC-6: Canvas text content sanitization |
| `sanitize_skill_instructions()` (injection guard) | SC-6: Canvas command schema validation |
| `validate_file_size()` (DoS prevention) | SC-5: Request body size limits |
| `validate_mcp_tool_name_strict()` (namespace isolation) | SC-4: WebSocket command type validation |

---

> Security review complete. All UI features must satisfy P0 exit criteria (16 items) before any network-accessible deployment. P1 criteria (12 items) before production. P2 criteria (7 items) as recommended enhancements. Total: 35 security exit criteria.
